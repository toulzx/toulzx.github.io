{"pages":[],"posts":[{"title":"语雀 + GitHub + Hexo 三端同步的自动化部署博客的搭建","text":"本文完整版已转移至 [yuque-hexo 自动化同步： PC &amp; GitHub &amp; Server 的安装与配置](https://www.yuque.com/toulzx/website-sync/ yuque-hexo-guide)​ ​ 食用声明​ 本文的目的是实现 **语雀** 编辑发布后，**GitHub Actions**** 自动同步到 **github.io** 以及 ****个人服务器**。由于没有找到类似的教程，便自己根据网络上的资料总结了一份，有些需要修改的地方会在本篇提出，相同的操作直接链接到了原文相应段落处，跳转查看即可，本文不再赘述。​ 如果你没有服务器并只想同步到 **github.io** ，那么阅读这篇文章足以：[**语雀自动同步到 hexo 博客**](https://www.yuque.com/hxfqg9/web/gtb5ck#rOPSH)。 **如果你符合如下要求，你将获得更好的体验： ** GitHub 使用基础 云服务器&amp;域名 购买和项目部署经历 使用搜索引擎解决问题的能力 能够稳定的访问 GitHub 和 Google ​ 本文目前仅在[**语雀**](https://www.yuque.com/toulzx/website-sync/yuque-github-hexo)、[**个人博客**](https://toulzx.github.io/)发布发布，不允许转载。​ 本地与服务器端的安装与配置、GitHub 个人仓库创建这篇文章已经写的很详细了：[安装 Hexo 博客并部署到 GitHub 或云服务器](https://blog.csdn.net/qq_43187818/article/details/104468721?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.no_search_link)，此处不再赘述。但请注意，当阅读到[部署到云服务器](https://blog.csdn.net/qq_43187818/article/details/104468721?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.no_search_link#t5)一节，完成安装 Git 以及配置仓库后，你需要停止并继续阅读本文。 补充：本地通过 ssh 连接云服务器请注意，这一步不是必须的。它只是方便你在电脑本地直接控制服务器，而不是使用云服务器的在线控制台。因此，如果你已经安装并配置过 XShell，或者你并不常使用服务器，这一步看起来就多此一举了。你可以跳过这一步。​ 如果你正在使用 Windows，我推荐你使用 git bash 而不是 cmd 来完成配置。按照教程，我们应该使用以下命令： 1$ ssh -v git@[云服务器的公网IP地址] 代码块符号说明： $ 表示这后面一条控制指令，你不需要输入$​ [这里会解释填什么] 表示这是个变量，它往往因人而异 然后你可能遇到如下报错： 1Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 你可以尝试登录 root 账户测试，但结果是一样的： 12345$ ssh -v root@[云服务器的公网IP地址]......Permission denied (publickey,gssapi-keyex,gssapi-with-mic) ​ 解决方法参考此文：[Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 解决方法](https://xiaojueguan.blog.csdn.net/article/details/84946557?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link)在 root 用户下，修改配置文件： 1$ sudo vim /etc/ssh/sshd_config 找到被 # 注释的如下命令，按 i 进入编辑模式，取消注释并修改成： 12PasswordAuthentication yesPermitRootLogin yes 按 esc 退出编辑模式，输入 :wq 保存修改。​ 再执行： 1$ sudo systemctl restart sshd 然后本地（PC）再次尝试登录服务器： 1$ ssh -v git@[云服务器的公网IP地址] 此时应该可以登录成功。​ 自动化部署此处参考了[Hexo 博客部署到腾讯云服务器全流程](https://blog.csdn.net/StaunchKai/article/details/82878928?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.no_search_link)并根据实际情况补充了内容 创建 git 裸库1234567891011$ su root # 注意是 root 用户下$ cd /home/git$ ls # 什么都没有$ git init --bare [website].git # 创建裸库，这里我就命名为 website.git$ ls # 可以发现，目录下已被新建 website.git$ chown git:git -R [website].git # 授权 使用 git-hooks 同步网站根目录这使用的是 post-receive/post-update 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 website.git 裸库的 hooks 文件夹中，新建 post-receive / post-update 文件（不同 git 版本不同，此处默认都创建）： 1$ vim [website].git/hooks/post-receive 1$ vim [website].git/hooks/post-receive 添加如下内容，并保存退出： 1git --work-tree=/home/www/website --git-dir=/home/git/[website].git checkout -f 赋予此文件权限： 1$ chmod +x /home/git/[website].git/hooks/post-receive 1chmod +x /home/git/[website].git/hooks/post-update hexo 同步 语雀 内容：此处内容参考[语雀自动同步到hexo博客](https://www.yuque.com/hxfqg9/web/gtb5ck#PV23h)。​ 语雀知识库路径设置仓库设置 -&gt; 知识库信息 -&gt; 路径 语雀 Token个人头像 -&gt; 账户设置 -&gt; Token -&gt; 新建 -&gt; 勾选读权限 安装并配置 [yuque-hexo](https://github.com/x-cold/yuque-hexo)1$ npm i -g yuque-hexo 然后在创建的 Hexo 项目的目录下的 package.json 文件中添加： 12345678910111213141516&quot;yuqueConfig&quot;: { &quot;postPath&quot;: &quot;source/_posts&quot;, &quot;cachePath&quot;: &quot;yuque.json&quot;, &quot;mdNameFormat&quot;: &quot;slug&quot;, &quot;adapter&quot;: &quot;hexo&quot;, &quot;concurrency&quot;: 5, &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;, &quot;login&quot;: &quot;[语雀用户名]&quot;, &quot;repo&quot;: &quot;[语雀用以更新博客的知识库路径名]&quot;, &quot;token&quot;: &quot;[语雀Token]&quot;, &quot;onlyPublished&quot;: true, &quot;onlyPublic&quot;: true }, &quot;devDependencies&quot;: { &quot;yuque-hexo&quot;: &quot;^1.6.0&quot; } 配置本地 _config.yml 文件此处的配置仅是方便本地手动上传，也可跳过。​ 在创建的 Hexo 项目的目录下，打开此文件，找到 #deployment，添加如下内容： 1234567deploy:- type: git repo: https://github.com/[username]/[username].github.io branch: master- type: git repo: git@[服务器公网IP]:/home/git/website.git branch: master 后来创建的仓库默认 branch-name 可能是 main，请根据实际情况修改，当你不确定的时候，可以除去 branch 项，你只需确保仓库仅有一个分支即可。 这时候使用以下命令，就会把语雀的文章给下载下来，下载到 \\source_posts： 1234567$ yuque-hexo sync # 把语雀的文章给下载下来，下载到 \\source\\_posts$ hexo generate # 生成静态文件$ hexo server # 可在浏览器输入 localhost:4000 查看预览$ hexo deploy # 部署（到服务器） GitHub Actions 自动更新此处参考了：[Github Actions 自动部署 Hexo 博客至个人服务器](https://blog.csdn.net/qq_51661411/article/details/117458995#t3)​ 创建 GitHub Token 、仓库 以及 仓库Secrets直接看[此处](https://www.yuque.com/hxfqg9/web/gtb5ck#rOPSH) 。图文并茂，简单明了。​ 请注意，仓库 Secrets，除了 GH_TOKEN 和 GH_REF 之外，你还需要额外创建几个 Secrets，这在链接中没提及。 HEXO_DEPLOY_PRI ：它的内容取自本地 C:\\Users\\[PC-username]\\.ssh\\id_rsa，将该文件所有内容复制出来即可。 GH_USERNAME ：填写你的 GitHub 名称 GH_EMAIL ：填写你的 GitHub 绑定的邮箱 ​ 并且，workflow 的内容以此处为准： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263name: website-syncon: [push, repository_dispatch]jobs: blog-sync-deploy: name: Hexo blog build &amp; deploy runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: - name: Checkout codes uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache node modules uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} - name: Install dependencies run: | npm install hexo-cli -g npm install yuque-hexo -g npm install - name: Sync run: yuque-hexo sync - name: Generate files run: | hexo clean hexo generate - name: Server Authentication env: ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }} run: | mkdir -p ~/.ssh/ echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan ${{ secrets.GH_IP }} &gt;&gt; ~/.ssh/known_hosts git config --global user.name &quot;${{ secrets.GH_USERNAME }}&quot; git config --global user.email &quot;${{ secrets.GH_EMAIL }}&quot; - name: Deploy blog run: | git config --global user.name &quot;${{ secrets.GH_USERNAME }}&quot; git config --global user.email &quot;${{ secrets.GH_EMAIL }}&quot; git clone https://${{ secrets.GH_USERNAME }}:${{ secrets.GH_TOKEN }}@${{ secrets.GH_REF }}.git .deploy_git hexo deploy 注意，此代码块中的 [] 不是上文规定的意思， [] 是代码中包含的内容，请勿除去。​ 配置 serverless 云函数请看此处。​ ​ 大功告成恭喜你！ 参考资料 【语雀】语雀自动同步到 hexo 博客 | yichen 【CSDN】Hexo 博客部署到腾讯云服务器全流程 | CareyQ03 【CSDN】安装 Hexo 博客并部署到 GitHub 或云服务器（细节教程，越过各种坑）| 桐谷柯南 【CSDN】Hexo 搭建 - 部署服务器 | Dawson_ 【CSDN】nginx server 中的 root 和 location 的 root 的区别 | fengzyf 【CSDN】Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 解决方法 | xiaojueguan 【博客园】git init 和 git init –bare 的区别 | 接近风的地方 coc 【CSDN】Github Actions 自动部署 Hexo 博客至个人服务器 | 不染轻裳 【CSDN】ssh 免密以后还是需要输入密码：ssh 配置的一些坑 | Van_2009 【CSDN】SSH 简介及两种远程登录的方法 | Jack LDZ ​","link":"/2021/09/20/yuque-github-hexo/"},{"title":"Hello World","text":"这是一篇测试文档，我想看看我的配置是否正确？​ ​ ​ 看的到可爱的鹿鸣吗？ 🙃 果然没正常显示啊，那稍后在主题的 layout 文件夹中的 post.ejs 文件中加上这个试试： 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 🎈 如果你可以看到这条消息说明此时你已经成功实现了 toulzx.top(SERVER) - github.io - yuque 三者之间的联通~​ ​ 🎐 如果你还能看到这条消息说明你已经成功实现了自动化完成多端发布的配置。​ ​ 😥 其中还是遇到很多困难…虽然但是，一定可以解决的！ ​ 成功！恭喜你，接下来开始你的博客之旅吧。​ ​ 由于网站尚在建设中，特此申明本网站（toulzx.top）备案信息如下:​ 粤 ICP 备 2020135754 号","link":"/2021/09/18/test/"},{"title":"yuque-hexo 自动化同步： PC &amp; GitHub &amp; Server 的安装与配置","text":"本文目前仅在语雀、个人博客发布发布，不允许转载。谢谢！ 本文的目的是实现语雀编辑发布后，GitHub Actions 自动同步到 github.io 以及 个人服务器。​ 引用声明这篇教程是根据网络上的资料形成的，本篇教程引用内容声明如下：​ 版权声明：本文参考了 CSDN 博主「桐谷柯南」的原创文章，遵循 CC 4.0 BY-SA 版权协议。原文链接：安装 Hexo 博客并部署到 GitHub 或云服务器（细节教程，越过各种坑）本文本地部署、GitHub 部署、Server 部署内容摘录其本地与服务器端的安装与配置部分的教程，并作修改。 ​ 版权声明：本文参考了 CSDN 博主「Jack LDZ」的原创文章，遵循 CC 4.0 BY-SA 版权协议。原文链接：SSH 简介及两种远程登录的方法本文Server 部署-设置 SSH部分内容摘录了其SSH 两种级别的远程登录-公钥登录部分的教程，并作修改。 ​ 版权声明：本文参考了 CSDN 博主「CareyQ03」的原创文章，遵循 CC 4.0 BY-SA 版权协议。原文链接：Hexo 博客部署到腾讯云服务器全流程本文自动化部署部分内容摘录了其自动化部署部分的教程，并作修改。 ​ 版权声明：本文参考了 CSDN 博主「不染轻裳」的原创文章，遵循 CC 4.0 BY-SA 版权协议。原文链接：Github Actions 自动部署 Hexo 博客至个人服务器本文自动化部署部分内容摘录了其自动化部署部分的教程，并作修改。 ​ 版权声明：本文参考了语雀博主「yichen」的原创文章。原文链接：语雀自动同步到 hexo 博客本文自动化部署、后续-图片无法正常展示部分内容摘录了此教程内容，并作修改。 ​ 如果你没有服务器或只想同步到 github.io ，那么阅读这篇语雀即可：语雀自动同步到 hexo 博客。 下面开始我们的探索吧：） 本地 PC 部署本地主机以 Windows 10 系统为例。 1. 安装 Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是一个让 JavaScript 运行在服务端的开发平台。 Node.js 的官方下载地址：https://nodejs.org/当然它也有中文网：http://nodejs.cn/ 建议下载 LTS（即 Long Term Support，长期技术支持）（此处是** 64 位**版本的，其他版本如源码可以在 DOWNLOAD 界面找到），较为稳定，下载文件，安装过程基本直接下一步即可。安装完成后使用 命令提示符（以下均简写 cmd） 查看是否安装成功。 123$ node -v # 查看 node 版本，也可使用 $ node --version，下同$ npm -v # 查看 npm 版本 代码块符号说明： $ 表示这后面一条控制指令，你不需要输入$ # 表示这后面是注释语句，不会被执行，你不需要输入# 往后不再额外声明。 出现安装的版本号说明安装成功。 2. 安装 Git Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Git Bash 和 CMD 的区别：Bash 是基于 CMD 的，Bash 在 CMD 的基础上新增了一些命令和功能，故建议使用 Bash 更方便。 我们建议你使用 Git Bash 替代 CMD，Git Bash 可以便捷后续的操作。​ ​ 官方网站：https://git-scm.com/ 选择 Windows 版本安装。按照官方文档推荐中国大陆用户从 淘宝 Git for Windows 镜像 下载 Git（说得对）。macOS 和 Linux 系统都有自带的 Terminal 终端方便下载 Git 。 3. 安装 HexoHexo 的官方网站：https://hexo.io/ 该博客框架拥有中文文档，有些资料需要参考文档。 由于 npm 服务器在国外，因此使用 npm 直接下载可能会遇到卡顿的问题（除非你可以流畅地科学上网），所以我们先将 npm 转换成淘宝的镜像源： 1$ npm config set npm config set registry https://registry.npm.taobao.org 然后安装 cnpm ： 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 然后通过 cnpm 安装 Hexo： 1$ cnpm install -g hexo-cli 等待安装结束。​ 选择一个目录来初始化博客，例如 E:/ 目录下： 123$ cd e:$ hexo init website$ cd website 执行成功后安装两个插件： 12345$ npm install hexo-deployer-git --save$ npm install hexo-server --save# 或者按照官方文档 直接 使用命令一步安装：$ npm install [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git) 允许你在本地快捷地实现 hexo 的 git 部署。 [hexo-server](https://github.com/hexojs/hexo-server) 允许你在本地服务器上预览博客。 ​ 安装成功后可在本机查看自己的博客了： 1$ hexo server # 或简写成 $ hexo s 打开浏览器输入 localhost:4000 可以看到初始界面。按 Ctrl+C 关闭本地服务器。​ ​ GitHub 部署首先你得有个 GitHub 账户，这里就不提供创建账户的教程了。 1. 创建 GitHub Pages 格式的公有仓库 这个仓库将存放 hexo 编译后的博客静态页面 打开 GitHub ，点击 new 一个 repository，创建一个新的仓库，仓库名称必须要遵守 GitHub Pages 的格式： [your-username].github.io。 编者注：一般无需勾选 Initialize this repository with a README。 建好仓库后，在 Settings 设置中有一个 GitHub Pages 一项，里面就写着 GitHub Pages 为我们创建好的域名。在浏览器中访问就可以看到一个初始的界面。这就是博客的默认地址，当然后面我们也可换成自己的域名。 2. 设置 SSH务必确保在 本地 PC 已经完成了 Node.js、Git 和 Hexo 的安装，本地（PC）打开 Git Bash。​ 如果是第一次使使用 Git 的话，需要配置如下信息： 12$ git config --global user.name [your-username]$ git config --global user.email [your-email] 代码块符号说明：[tips here] 表示这是个变量，其内容因人而异，你不需要输入[] ​ 在本机生成密钥对使用 ssh-keygen 生成私钥和公钥： 1$ ssh-keygen -t rsa -t表示类型选项，这里采用 rsa 加密算法。​ 然后根据提示一步步的按 enter 键即可，注意，出于安全考虑，建议为私钥设置密码（如果不想设置就按 enter 跳过即可）。​ 根据提示找到你的密钥 id_rsa 和公钥 id_rsa.pub 的位置。​ GitHub 配置 SSH 此步骤非必须，但推荐。目的是方便本地 Git 的后续操作（不用每次都登录且更加安全）。 打开 GitHub 并登录，依次点击：头像 -&gt; Setting -&gt; SSH and GPG keys -&gt; New SSH key​ 将刚刚生成的公钥 id_rsa.pub 文件里的内容复制到 Key 里面（用记事本打开公钥文件即可），名称任意，然后选择添加，GitHub 提示输入密码确认后完成添加。​ 接着在 本地 PC 的 Git Bash 上输入： 1$ ssh -T git@github.com 第一次的时候依旧会让你 yes 确认 ，如果看到 Hi 后面是自己的用户名，就说明成功了。​ 3. 从本地 PC 上推送到 GitHub接下来回到我们的 PC 上，在刚刚我们生成的 e:/website 目录下，找到 hexo 的配置文件 _config.yml，用编辑器打开它（文本编辑器、Notepad++或 VScode 都行）。修改最下面有个 deploy 的配置： 1234deploy:- type: git repo: git@github.com:[your-username]/[your-username].github.io.git branch: main 注意缩进。注意，以前创建的仓库分支 branch 的默认名称应该是 master，如果你不清楚，请先查看你的分支名。​ 保存并退出，然后发布到 GitHub 上： 1234567891011$ hexo clean$ hexo generate # 构建$ hexo server # 可选，本地服务器查看$ hexo deploy # 部署到 GitHub# 当然也可简写成:$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 这里不一定每次都要 clean，clean 会清除缓存，导致一些网站的计数脚本清零。​ 在 本地 PC 浏览器上输入 GitHub Pages 的域名 https://[your-username].github.io ，就可以在互联网上访问你的博客了。​ Server 部署首先你需要拥有一个服务器和域名，例如阿里云 ECS、阿里云轻量应用服务器、腾讯云 CVM、百度云 BCC 等。这里不再提供购买和配置的教程了。​ 这里提醒一下，检查安全组的应用类型 HTTP 协议 TCP 端口 80 是否设置打开，没有的话需配置一下安全组： 建议使用 Linux 系统的服务器镜像。这里以使用云服务器的 CentOS 为例。​ 1. 搭建 nginx Nginx 是一款轻量级的 Web 服务器 / 反向代理服务器及电子邮件代理服务器，在 BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上 nginx 的并发能力在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 使用云服务商提供的远程登陆登录进云服务器，输入下列命令进入 root 用户： 1$ sudo su root 安装 nginx： 1$ yum install -y nginx 安装成功后使用开启环境： 1$ nginx 在本地 PC 的浏览器中输入云服务器的公网 IP（如果你链接了域名，也可输入域名），就会显示类似界面：以上界面是 CentOS 版本的，其他服务器会有所不同。 2. 配置 nginx实际上我们需要将这个地址指向我们的博客，接下来我们去修改 nginx 的配置文件： 12345$ cd /etc/nginx # 进入路径$ vi nginx.conf # 使用vim编辑器编辑配置文件# 输入 i 进入编辑模式，可以修改文件 提示：阿里云和腾讯云下载库中，默认的配置文件是位于 /etc/nginx 下的 nginx.conf，有些服务器可能是 /etc/nginx/conf.d/default.conf ，按照官方的安装方法则可能是/etc/nginx/conf/nginx.conf 我们需要修改如下内容： 将最上一行的 user 改为 root（或者创建名为 nginx 的用户并给予权限） 向下寻找，在 http 中更改 root 指向的路径，比如我这里选择 /home/www/website ，当然此时我们还没有创建这个文件夹。 同时如果有了域名的话可以在 server_name 写上域名。 12# 编辑结束之后，按 esc 键退出编辑# 然后输入 :wq 并敲回车键，保存并退出 vim 文件编辑器 创建我们所指定的路径： 1234$ cd ~/home ## 这一步找不到路径的可尝试 $ cd ~/../home$ mkdir www$ cd /www$ mkdir website 这样我们就得到了博客的根路径 /home/www/website ，这与 nginx.conf 文件设置的内容相对应。​ 3. 安装 Node.js在 Linux 系统上安装 Node.js 的方法有很多种，详细可以参考搜索引擎或者 Node.js 的 GitHub 文件。这里提供一种方法： 12345curl -sL https://rpm.nodesource.com/setup_13.x | bash -# 这里的setup_13.x指Node.js13的版本，可以改为其他版本，建议不要太低为好，hexo一些主题的Node.js版本都比较高。yum install -y nodejs 在安装过程中可能会发生下载速度极慢的情况，具体取决于云服务器选择的源。安装完成之后像我们 PC 上一样执行一下版本号命令： 123$ node -v$ npm -v 4. 安装 Git 并配置 git 用户 主要是让我们的 PC 可以通过 ssh 的方式连接到云服务器，然后我们可以通过 $ hexo deploy 将我们的博客推到服务器上。 安装 Git 1$ yum install git 添加名为 git 的用户： 1$ adduser git 修改并配置 sudoers 文件权限： 12$ chmod 740 /etc/sudoers$ vi /etc/sudoers 找到这段话并补充，同样是 vim 编辑器的操作： 12root ALL=(ALL) ALLgit ALL=(ALL) ALL 保存退出后将 sudoers 文件的权限改回来： 1$ chmod 400 /etc/sudoers 设置 git 用户的密码： 1$ sudo passwd git 5. 本地通过 ssh 连接云服务器 请注意，这一步不是必须的。它只是方便你在电脑本地直接控制服务器，而不是使用云服务器的在线控制台。因此，如果你已经安装并配置过 XShell，或者你并不常使用服务器，这一步看起来会显得多此一举了。 ​ 基本步骤在本地 PC（注意，不是服务器端！），将之前创建好的公钥复制到远程主机（服务器）中： 1$ ssh-copy-id git@[public-ip-of-your-server] 登录需要输入之前设置的密码。密码正确会显示已添加：继续在 本地 PC 使用以下命令： 1$ ssh -v root@[public-ip-of-your-server] 出现 git 用户的命令，成功登录。​ ERROR: Permission denied你可能遇到如下报错： 1# Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 你可以尝试登录 root 账户测试，但结果是一样的： 123$ ssh -v root@[public-ip-of-your-server]# Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 解决方法参考了此文：Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 解决方法在服务器端，root 用户下，修改配置文件： 1$ sudo vim /etc/ssh/sshd_config 找到被 # 注释的如下命令，按 i 进入编辑模式，取消注释并修改成： 12PasswordAuthentication yesPermitRootLogin yes 按 esc 退出编辑模式，输入 :wq 保存修改。​ 再执行： 1$ sudo systemctl restart sshd 然后本地（PC）再次尝试登录服务器： 1$ ssh -v git@[云服务器的公网IP地址] 此时应该可以登录成功。 自动化部署实现 语雀 编辑发布后，借助 serverless 云函数 和 GitHub Actions 自动同步到 github.io 以及 个人服务器上。 1. 创建 git 裸库在服务器端（你现在可以选择使用云服务器在线登录，或者本地 ssh 连接了）创建裸库： 1234567891011$ su root # 注意是 root 用户下$ cd /home/git$ ls # 什么都没有$ git init --bare [website].git # 创建裸库，这里我就命名为 website.git$ ls # 可以发现，目录下已被新建 website.git$ chown git:git -R [website].git # 授权 2. 使用 git-hooks 同步网站根目录这使用的是 post-receive/post-update 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 website.git 裸库的 hooks 文件夹中，新建 post-receive / post-update 文件（不同 git 版本不同，此处就都创建了）： 1$ vim [website].git/hooks/post-receive 1$ vim [website].git/hooks/post-receive 添加如下内容，并保存退出： 1git --work-tree=/home/www/website --git-dir=/home/git/[website].git checkout -f 赋予此文件权限： 1$ chmod +x /home/git/[website].git/hooks/post-receive 1$ chmod +x /home/git/[website].git/hooks/post-update 3. hexo 同步语雀内容安装并配置 yuque-hexo先登录语雀，创建一个互联网可见的知识库。​ 语雀知识库路径设置：仓库设置 -&gt; 知识库信息 -&gt; 路径语雀 Token 设置：个人头像 -&gt; 账户设置 -&gt; Token -&gt; 新建 -&gt; 勾选读权限 安装并配置 yuque-hexo： 1$ npm i -g yuque-hexo 然后在创建的 Hexo 项目的目录下的 package.json 文件中添加： 12345678910111213141516&quot;yuqueConfig&quot;: { &quot;postPath&quot;: &quot;source/_posts&quot;, &quot;cachePath&quot;: &quot;yuque.json&quot;, &quot;mdNameFormat&quot;: &quot;slug&quot;, &quot;adapter&quot;: &quot;hexo&quot;, &quot;concurrency&quot;: 5, &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;, &quot;login&quot;: &quot;[语雀用户名]&quot;, &quot;repo&quot;: &quot;[语雀用以更新博客的知识库路径名]&quot;, &quot;token&quot;: &quot;[语雀Token]&quot;, &quot;onlyPublished&quot;: true, &quot;onlyPublic&quot;: true }, &quot;devDependencies&quot;: { &quot;yuque-hexo&quot;: &quot;^1.6.0&quot; } 配置本地 _config.yml 文件 此处的配置仅是方便后续本地手动上传 ​ 在创建的 Hexo 项目的目录下，打开此文件，找到 deploy，添加如下内容： 123- type: git repo: git@[public-ip-of-your-server]:/home/git/[website].git branch: master 添加完后完整的 deploy 应该是这样的： 1234567deploy:- type: git repo: https://github.com/[your-username]/[your-username].github.io branch: main- type: git repo: git@[public-ip-of-your-server]:/home/git/[website].git branch: master 这时候在本地使用以下命令，就会把语雀的文章给下载下来，下载到 \\source_posts： 1$ yuque-hexo sync 部署的流程仍然一致，只不过现在可以同时部署到 github.io 以及服务器了： 12345$ hexo generate # 生成静态文件$ hexo server # 可在浏览器输入 localhost:4000 查看预览$ hexo deploy # 部署（到github.io 和服务器） 4. 创建私有仓库并设置 GitHub Actions创建私有仓库 存放 hexo 源码，并用来执行自动化 在 github 上创建一个私有仓库，这里将它命名为 yuque-website-sync，你可以任意命名。 注意：在仓库里面再放一个仓库是没法把里面那个仓库 push 到 github 的，只会传一个空文件夹，导致后期博客成了空白页面，最简单粗暴的办法就是把你 git clone 的 hexo 主题里的 .git 文件夹给删掉 然后在构建了博客的 hexo 目录下运行如下命令（这里是之前提到的路径 E:/website）： 12345$ git init$ git add .$ git commit -m &quot;first commit&quot;$ git remote add origin https://github.com/[your-username]/[yuque-website-sync].git$ git push -u origin main 创建 GitHub Token点击：头像 -&gt; Setting -&gt; Developer setting -&gt; Personal access tokens 只勾上 repo 这一类即可 生成了 token 之后一定要记下来，只展示 1 次，往后再回来就没法看了。 添加仓库 Secrets 在执行 GitHub Actions 时，使你的隐私信息不会暴露。但即便这样，仍然不建议你将仓库设置为 public，因为在 安装并配置 yuque-hexo 时，你在 package.json 文件中添加了 语雀 的 token。 ​ 打开新创建的私有仓库，点击：setting -&gt; Secrets -&gt; New repository secret​ 创建如下 secrets： GH_USERNAME：填写你的 GitHub 名称 ​GH_EMAIL：填写你的 GitHub 绑定的邮箱 GH_REF ：博客的仓库地址 github.com/[your-username]/[your-username].github.io（注意去掉前面 https://） GH_TOKEN ：刚才生成的 token GH_PUBLIC_IP ：服务器的公网 IP HEXO_DEPLOY_PRI ：取自本地 PC 的 id_rsa（详见之前的内容：在本机生成密钥对），将该文件所有内容复制出来即可 创建 Actions然后来到 Actions，点击 set up a workflow yourself ​ workflow 的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960name: Website Syncon: [push, repository_dispatch]jobs: website-sync: name: Hexo blog build &amp; deploy runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: - name: Checkout codes uses: actions/checkout@v2 - name: Setup node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache node modules uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} - name: Install dependencies run: | npm install hexo-cli -g npm install yuque-hexo -g npm install - name: Sync run: yuque-hexo sync - name: Generate files run: | hexo clean hexo generate - name: Server Authentication env: ACTION_DEPLOY_KEY: ${{ secrets.GH_KEY }} run: | sudo timedatectl set-timezone &quot;Asia/Shanghai&quot; mkdir -p ~/.ssh/ echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan ${{ secrets.GH_PUBLIC_IP }} &gt;&gt; ~/.ssh/known_hosts git config --global user.name &quot;${{ secrets.GH_USERNAME }}&quot; git config --global user.email &quot;${{ secrets.GH_EMAIL }}&quot; - name: Deploy blog run: | git config --global user.name &quot;${{ secrets.GH_USERNAME }}&quot; git config --global user.email &quot;${{ secrets.GH_EMAIL }}&quot; git clone https://toulzx:${{ secrets.GH_TOKEN }}@${{ secrets.GH_REF }} .deploy_git hexo deploy 注意，此代码块中的 [] 不是上文规定的意思， [] 是代码中包含的内容，请勿除去。​ 点击 commit 保存配置，然后点击 Actions，可以看到自动化执行。点进去可以看执行的详情，正常情况过一会就和图示历史记录一样，执行成功。​ 5. 配置 serverless创建云函数以腾讯云为例，搜索云函数，新建一个函数服务： 选择：自定义创建 -&gt; 事件函数 -&gt; 函数名称任意 -&gt; 地域视情况而定 -&gt; 代码部署 -&gt; 环境为 Python2.7 -&gt; 代码提交方法为在线编辑​ 代码内容填写 1234567891011121314# -*- coding: utf8 -*-import requestsdef main_handler(event, context): r = requests.post(&quot;https://api.github.com/repos/[your-username]/[private-repo-name]/dispatches&quot;, json = {&quot;event_type&quot;: &quot;run-it&quot;}, headers = {&quot;User-Agent&quot;:'curl/7.52.1', 'Content-Type': 'application/json', 'Accept': 'application/vnd.github.everest-preview+json', 'Authorization': 'token [你创建的TOKEN]'}) if r.status_code == 204: return &quot;This's OK!&quot; else: return r.status_code 修改r = requests.post()内容，仓库是刚刚那个私有仓库。注意，那个 token 是带着的，完整的格式是 'Authorization': 'token xxxxxxxxxxxxxx'。​ 点击完成，开始部署。部署完毕后点下面那个测试，返回 This's OK! 说明代码该函数可以正常访问到私有仓库创建的 Actions。 同时私有仓库的 GitHub Actions 也会收到指令 过一阵就成下面那个绿色的对号了，然后去访问一下博客，看看是否正常。 创建触发器点击：触发管理 -&gt; 创建触发器 选择：默认流量 -&gt; API 网关触发 -&gt; 新建 API 服务 -&gt; 请求方法 ANY -&gt; 发布环境 发布 -&gt; 鉴权方法 免鉴权 -&gt; 不选择集成响应 他会给你一个访问路径，记下来 6. 配置语雀 Web Hook在知识库中：··· -&gt; 设置 -&gt; 开发者 -&gt; 添加 Web Hook -&gt; 其它渠道 将触发器的 URL 粘贴在此处，命名任意，勾选发布和更新文档。 添加 Web Hook 成功，可点击测试，查看 GitHub Actions 、 github.io、 域名下网站的情况。 后续恭喜你，到这里你就完成了所有配置！ 配置主题你已经完成了 hexo 的自动化部署，现在你在语雀上指定的公开知识库里创建和更新的文章，都会同步到你的 GitHub Pages 以及 个人服务器上。​ 但是，你的网站仍然显得非常单调和粗糙，现在，是时候寻找一个合适的主题来装饰你的网站了。你可以访问：https://hexo.io/themes/；或者直接在 GitHub 搜索 “hexo theme”.​ 玩得愉快！​ 图片无法正常展示解决方法参考：语雀 cdn 防盗链临时解决方案 #41不同主题的处理方法不同，你可能需要在 themes/layout/ 中找到类似 post.ejs 的文件，并添加在正文部分之前添加： 1&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 类似这样：不过，正文部分的代码可能从 post.ejs链接到另一个文件中：打开对应文件，找到正文部分，在前面添加这段代码即可： 或者，你也可以直接在设置 img 标签的 referrerpolicy 属性： 123456&lt;img width=&quot;120&quot; height=&quot;120&quot; src=&quot;https://cdn.nlark.com/yuque/.../.png&quot; referrerpolicy=&quot;no-referrer&quot;/&gt; 参考资料【语雀】语雀自动同步到 hexo 博客 | yichen【CSDN】Hexo 博客部署到腾讯云服务器全流程 | CareyQ03【CSDN】安装 Hexo 博客并部署到 GitHub 或云服务器（细节教程，越过各种坑）| 桐谷柯南【CSDN】Hexo 搭建 - 部署服务器 | Dawson_【CSDN】nginx server 中的 root 和 location 的 root 的区别 | fengzyf【CSDN】Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 解决方法 | xiaojueguan【博客园】git init 和 git init –bare 的区别 | 接近风的地方 coc【CSDN】Github Actions 自动部署 Hexo 博客至个人服务器 | 不染轻裳【CSDN】ssh 免密以后还是需要输入密码：ssh 配置的一些坑 | Van_2009【CSDN】SSH 简介及两种远程登录的方法 | Jack LDZ​","link":"/2021/09/20/yuque-hexo-guide/"},{"title":"NJUPT-CG-OpenGL 学习笔记","text":"由于疫情，南京邮电大学 2021-2022-1 的计算机图形学课程（课程代号：B0301312C ）采用了线上教学模式。鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 bilibili 弹幕网（BV1ib4y1Y74J）。此外，根据上课内容，我上传了在线授课过程中的代码（toulzx/NJUPT-CG-OpenGL）供大家参考。^本文目前仅在语雀、个人博客发布发布，内容为作者 tou 原创，不允许转载。谢谢！ README声明本文目前仅在语雀、个人博客发布发布，内容为作者 tou 原创，不允许转载。谢谢！ 简介由于疫情，南京邮电大学 2021-2022-1 的计算机图形学课程（课程代号：B0301312C ）采用了线上教学模式。 鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 bilibili 弹幕网（BV1ib4y1Y74J）。此外，根据上课内容，我上传了在线授课过程中的代码（toulzx/NJUPT-CG-OpenGL）供大家参考。​ 如何食用项目结构 文件夹 Source 文件夹 HelloCG：此项目文件夹 一些文件 .PDFs：功能库配置教程 一些文件 .ZIPs：功能库 ​ 查阅历次代码及差异我按照课程教学顺序，将历次课程代码提交到此仓库下。 test_4 分支的最新一次 commit 内容是本课程的最后一次作业（第 4 次作业），它是基于最后一次课程的代码内容。由于此分支包含了所有课程的代码内容的 commits，因此我将此分支设置为默认分支。 此外，此前另外 3 次作业的代码不在课程教学内容中，因此我额外创建了 test_3 、test_2 、test_1 分支，他们是从默认分支的某次课程内容延伸出去的。 你可以点击仓库主页的 commits，这可以阅览历次 commit 的信息， 当你点击 某次 commit 的标题 时，你可查看和上一次 commit 内容的差异，我认为这可能会方便大家查看历次课程代码的差异。 ⚠ 注意：这样的做法是我的首次尝试，有些 commits 的差异由于失误并不能正确预览，我会在出现这种情况的 commit 差异页面提供批注。当然，你完全可以不参考 commit 差异，你仍然可以下载运行可使用的的历次课程代码（见下）。​ 历次课程代码文件夹目录链接当你点开任意课程代码对应的 commit 链接后，即可查看相应课程内容对应的代码文件： Week2-1 初始环境配置和 Demo 测试 Week2-1 梳理、重写 Demo Week2-2 &amp; Week3-1 使用着色器绘制一个三角形 Week3-2 优化代码结构，将着色器部分代码独立存放 Week4-1 为三角形各个顶点设置不同的颜色 Week4-1 使用两个三角形拼成正方型 Week4-1 Exercise1 实现矩形颜色交替变换 Week5-1 改用点和连接信息绘制正方形 Week5-1 清理代码，准备学习纹理部分 Week5-1 配置 SOIL2 Week5-2 尝试纹理贴图 Week5-2 Exercise2 使纹理单方向渐变移动 Week6-1 配置 GLM 库；清理代码，去除纹理部分，back to Week4-1 Week7-1 正方体的缩放、旋转、平移 Week7-2通过透视投影生成真正的正方体 Week7-2 Exercise3 地月模型旋转（近似圆轨道 + 23.5°） Week8-1 实现摄像机（即观察者）视角的移动（w/a/s/d） Week8-1 实现摄像机视角移动的鼠标和滚轮事件 Week8-2 &amp; Week8-3 实现旋转光源照射物体的效果 Week8-3 Exercise4 &amp; fix 实现控制物体的（↑/↓/←/→）移动 &amp;&amp; 修复 x 轴光照位置的错误 ​ 下载你可以通过 Git 直接将项目 clone 到本地，然后借助编辑器内置的 Git 管理工具即可轻松切换历次版本。如果你看不懂上面这一行我在说什么，你可以拷贝链接到 DownGit 下载。 友情链接关于教程我推荐你学习这篇教程：LearnOpenGL，你会发现此课程（特指 2021-2022 学年第 1 学期的线上课程）的授课思路参考了这份教程。​ 课程笔记 &amp; 代码 【CSDN】OpenGL 初学者入门——学习指南 【CSDN】南邮计算机图形学实验报告 【GitHub】 GodWuzZ/Graphics 【yuque】tou/NJUPT-CG-OpenGL 一点建议不要未经思考直接 copy 代码。 首先，这对你学习这门课程没有好处；其次，睿检查作业的时候，会查看你的代码并询问细节。（不要尝试在睿的雷区蹦迪，你真的会后悔的） NotesWeek 2-1初始环境配置 你可以参考：【LearnOpenGL】编译和链接 GLEW ​ 配置附加库目录，并使用静态链接的方式引用你需要下载本课程会使用到的附加库，并把它放在指定位置（你可以直接使用我仓库中上传的库）： 在项目属性配置中，将附加库的目录添加进来step1: step2: step3:123opengl32.libglew32s.libglfw3.lib ​ 注意： glfw 配置链接器的附加库目录的时候注意根据 Visual Studio 版本选择。 建议统一使用 32 位。 ​ 在测试代码中引用附加库目录12345//GLEW 采用静态编译的方式#define GLEW_STATIC#include &lt;GL/glew.h&gt;//GLFW#include &lt;GLFW/glfw3.h&gt; #define GLEW_STATIC：如果存在则优先使用静态库。#include &lt;GL/glew.h&gt;： 就是这张图中的路径：同理 glfw.​ 当你正确添加了附加库目录后，以上代码段编辑器不会标红报错。​ 然后你可以尝试使用 DEMO 测试运行：👉 测试 demo 的代码​ 测试效果如下： 重写 Democonst GLint WIDTH = 800, HEIGHT = 600;窗口大小定义为常量。GLint 前缀 GL 表示 OpenGL 支持的数据类型（支持 C、C++ 所有基本数据类型，只不过要增加前缀）OpenGL 主要使用 int unsignedInt float （显卡用不到 double 类型，资源浪费，我们需要在不损失性能的情况下拥有最快速度）。​ glfwInit()初始化.函数命名方式有特点 ： 小写库名+函数名​ glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);属性.glfw 主副版本号设置：3.3​ glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);属性.窗口用途：画 OpenGL ，使用版本： CORE OpenGL​ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);属性.使其向前兼容 (Mac 必须写，Win 系统已经默认了）​ glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);属性.不允许改变窗口大小，会影响投影、透视的情况.​ GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Learn OpenGL&quot;, nullptr, nullptr);GLFW 固定变量命名方式特点： 大写库名+变量名.宽、高、标题、全屏、多屏​ int screenWidth, screenHeight;glfwGetFramebufferSize(window, &amp;screenWidth, &amp;screenHeight);获得显存下实际窗口大小.屏幕硬件可能导致显示的每 1 个像素的硬件构成不止 1 个，由于屏幕显示直接映射在显存上，这种情况下显存空间大于屏幕显示的空间尺寸.​ glfwMakeContextCurrent(window);设置焦点为当前窗口​ glewExperimental = GL_TRUE;必须设置的参数怪异的保留变量，函数的命名方式，变量的赋值 glViewport(0, 0, screenWidth, screenHeight);视口.左下角坐标、显存空间的宽高，这里明显填满了整个窗口​ glfwPollEvents();获取标志信息.比如：鼠标、键盘使用信息，都会被标志（Week 2-1 还用不到）​ glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);初始化一个颜色.颜色用浮点数表示，如果有 alpha 值就不压缩​ glClear(GL_COLOR_BUFFER_BIT);用此颜色清理缓存区，进行初始化赋值操作（设置背景色）​ glfwSwapBuffers(GLFWwindow* window); 双缓存机制.当传输当前帧时，利用这个时间加载下一帧（创建空间绘制下一帧）​ ​ Week 2-2 &amp; Week 3-1顶点着色器（Vector Shader）123456#version 330 corelayout(location = 0) in vec3 position;void main(){gl_Position = vec4(position, 1.0f);} #version 330 core类似 core profile 含义，版本号 3.3​ layout(location = 0) in vec3 position;如何从显存获取并映射变量.变量 position .三个浮点数构成的向量 vec3.从显存硬件区域直接获取 in.​ gl_Position = vec4(position, 1.0f);最终顶点信息.gl_Position 预保留变量，四维信息.​ 片元着色器（Fragment Shader）大部分情况等同 像素着色器 Pixels Shader有时候 1 个像素被不同着色器覆盖绘制多次，片源的描述更准确。 123456#version 330 coreout vec4 color;void main(){ color = vec4(1.0f, 0.5f, 0.2f, 1.0f); // 使他偏橙色} color = vec4(1.0f, 0.5f, 0.2f, 1.0f);颜色四维.对每个片源进行颜色赋值.​ 导入并编译着色器GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);创建着色器对象.​ glShaderSource(vertexShader, 1, &amp;vertexShaderCode, NULL);把代码存入，传 1 个，代码，起始位置 NULL（整个传）.​ glCompileShader(vertexShader);编译.生成目标代码也在 vertexShader 了里面东西很多了：源代码、编译过程状态、失败日志、成功标志位、编译结果.​ ​ glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);后缀iv ：能够获取的返回参数的数据类型 integer &amp; vertexCOMPILE_STATUS ： 这里是编译状态的标志位success： 存放编译状态信息​ 创建并链接可执行文件略​ 屏幕坐标系​ 你可以参考：【LearnOpenGL】坐标系统 | 进入 3D ​ OpenGL 采用右手坐标系：z 朝外为正，x 右，y 上​ 传入数据到显卡 你可以参考：【LearnOpenGL】你好，三角形 123456789101112131415161718192021222324252627GLfloat vertices[] ={ // position -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f};// 创建顶点正面对象（VAO）、顶点缓存对象（VBO）GLuint VAO, VBO;glGenVertexArrays(1, &amp;VAO);glGenBuffers(1, &amp;VBO);// 绑定 VAO、VBOglBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, VBO);// 数据传入显卡glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 设置 VAO// 对应此句：&quot;layout(location = 0) in vec3 position;&quot; 和上述 vertices[]glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);glEnableVertexAttribArray(0);// 解绑定 VAO、VBOglBindBuffer(GL_ARRAY_BUFFER, 0);glBindVertexArray(0); 着色器不接收多余输入VAO 顶点正面对象：解释数据VBO 顶点缓存对象：传输数据，说明在显存空间上位置他们一定成对出现！绑定，先 a 后 b​ glBindBuffer(GL_ARRAY_BUFFER, VBO);在显卡上确定一段区域作为目的地.​ glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);设置标志位 static 表示常读不常写，这样显存会寻找合适位置分配.​ glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); 位置 0 3 个浮点数： 对应 vec3 （float） 从 vertices[] 起始位取 ：(GLvoid*)0 不需要对顶点标准化处理（-1 到 1 之间）： GL_FALSE 每次取 3 个 ​ 调用着色器1234glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3);glBindVertexArray(0); glUseProgram(shaderProgram);绑定着色器​ glDrawArrays(GL_TRIANGLES, 0, 3);position 从 0 开始，画 3 个顶点（两个三角形就是 6 个）​ Week 3-2​ 关于 Visual Studio 的“解决方案资源管理器”​ 添加文件注意，这里是逻辑添加，不一定对应实际文件夹路径：​ 建议先本地建好文件，对应添加进来： 关于着色器的文件后缀.fs 、.vs 只是我们为了方便区分顶点着色器和片源着色器而进行个性化命名的。​ 事实上，在 Week 2-2 &amp; Week 3-1 课程中，甚至是本次课程 Week 3-2 你就可能注意到，我们对顶点着色器和片源着色器的引用是通过调用这部分的代码的字符串内容： 12const GLchar* vShaderCode = vertexCode.c_str();const GLchar* fShaderCode = fragmentCode.c_str(); 防止头文件重复引用1#pragma once 或 1234#ifndef Shader_h // Shader.h 是文件名#define Shader_h#endif Week 4-11glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)(3*sizeof(GLfloat))); 注意这里是 3*sizeof(GLfloat)改变各个顶点颜色，要向顶点着色器中新传递颜色信息，并且要传给片元着色器： 12345// vertexShaderlayout(location = 1) in vec2 vertexColor;out vec3 ourColor; 12345// fragmentShaderin vec3 ourColor;color = vec4(ourColor, 1.0f); 效果：我们设置了三个顶点的颜色，为什么中间的颜色会相互融合？这里涉及到了栅格化的知识： 这个图片可能不是你所期望的那种，因为我们只提供了 3 个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓片段插值 (Fragment Interpolation) 的结果。当渲染一个三角形时，光栅化 (Rasterization) 阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。基于这些位置，它会插值 (Interpolate) 所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的 70% 的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是 30% 蓝 + 70% 绿。这正是在这个三角形中发生了什么。我们有 3 个顶点，和相应的 3 个颜色，从这个三角形的像素来看它可能包含 50000 左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。^以上内容引用自【LearnOpenGL】着色器 ​ 使用两个三角形拼成正方形​ 矩形的实现通过两个三角形合成.仔细看坐标其实我们要生成的是正方形，但是展示的结果是长方形，这个跟我们窗口长宽有关。​ 我们主要修改了这部分代码： 12345678910111213// 顶点位置集 rectangleGLfloat vertices[] ={ // position // color // first triangle 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // second triangle 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f}; 记得修改：glDrawArrays(GL_TRIANGLES, 0, 6);，我们使用了 6 个顶点绘制两个三角形了。​ ​ Week 5-1改用点和连接信息构建正方形 你可以参考：【LearnOpenGL】你好，三角形 | 索引缓冲对象（EBO） ​ 单纯用点来构成物体，当物体多样了，点多了，复杂度高我们使用点和连接信息来构建物体： 123456789101112131415// 定义点和颜色GLfloat vertices[] ={ // position // color 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右上 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 左上};// 定义连接信息unsigned int indices[] ={ 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形}; 连接信息使用 EBO（elemental buffer object 元素缓冲对象）生成绑定。​ VAO、VBO 一定成对出现但连接信息 EBO 并不是，随时可变。​ glDrawArrays(GL_TRIANGLES, 0, 6);while 中 此句不再适用了glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);改用此句​ ​ 配置 SOIL2 你可以参考：OpenGL SOIL2.pdf 根据参考链接做即可，项目中的配置方法和以前差不多，不过此处只需要添加一处附加库目录即可： Week 5-2纹理纠正一个网络上普遍的错误：OpenGL 推荐 2^n 的纹理，但不是强制的，它只是有利于生成多层渐进纹理。非 2^n 只是无法生成 mipmap（多层渐进纹理）。 你可以参考：【LearnOpenGL】纹理 | 纹理的环绕方式 glBindTexture(GL_TEXTURE_2D, texture);二维纹理：广泛被使用，图片 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);S、T、R（维度），对应 x、y、z（轴） glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);当纹理大于物体时候的设置glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);​当纹理小于物体时候的设置​ 1unsigned char* image = SOIL_load_image(&quot;images/T_Reflection_Tiles_D.BMP&quot;, &amp;imgWidth, &amp;imgHeight, 0, SOIL_LOAD_RGBA); 读图片.SOIL_LOAD_RGBA 当最后一个透明度没有也会强制生成不透明（即值为 1） 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, imgWidth, imgHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, image); GL_TEXTURE_2D 区域 第 0 层 目标区域 RGBA 宽高 边缘部分处理 和读取时候的最后一个参数一致 数据类型 图片 生成后即可解绑定.​ ​ glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture0&quot;), 0);while 中将纹理图片和纹理坐标对应​ uniform sampler2D texture0;sampler2D 实际上是 int 型​ glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture0&quot;), 0);这里第二个参数传 0 代表位置即可，不用是变量​ ourTextCoord = vec2(textCoord.x, 1 - textCoord.y);vertexShader中不这么设置，直接传的是上下颠倒的！因为 OpenGL 要求 y 轴 0.0 坐标是在图片的底部的，但是图片的 y 轴 0.0 坐标通常在顶部​ Week 7-1简单增加 36 个三角形vertices 中交换两块的位置，看到的颜色会变 深度测试新加入的颜色信息会覆盖原有的，你的立方体可能背面显示在正面之前了… glEnable(GL_DEPTH_TEST);开启深度测试glDepthFunc(GL_LESS);当小于再改变​ glClear(GL_COLOR_BUFFER_BIT | **GL_DEPTH_BUFFER**);while 中添加，使不要每次重新绘制 此时编译出来的正面就不是绿色而是红色了​ 只有深度、模板、颜色每次开启时需要重新初始化（while其它不用​ 正方体的平移、旋转和缩放123glm::mat4 transform = glm::mat4(1.0f);GLuint transLoc = glGetUniformLocation(ourShader.Program, &quot;transform&quot;);glUniformMatrix4fv(transLoc, 1, GL_FALSE, glm::value_ptr(transform)); 获得位置、数量、不进行转置、uniform 形式传值​ GLSL 两种获得输入的方式： _in__ 来自显存_ _uniform__ 来自 CPU_ ​ 1transform = glm::rotate(transform, glm::radians(20.0f)*static_cast&lt;GLfloat&gt;(glfwGetTime()), glm::vec3(1.0f, 1.0f, 1.0f)); 绕 (1,1,1) 向量轴旋转。static_cast&lt;GLfloat&gt;(glfwGetTime())临时使用的时间系数。​ transform = glm::scale(transform, glm::vec3(0.5f, 0.5f, 0.5f));缩放实际上是针对对角线的点操作 12345678910// main.cppglm::mat4 transform = glm::mat4(1.0f);transform = glm::translate(transform, glm::vec3(0.0f, 0.4f, 0.0f));transform = glm::rotate(transform, glm::radians(20.0f) * static_cast&lt;GLfloat&gt;(glfwGetTime()), glm::vec3(1.0f, 1.0f, 1.0f));transform = glm::scale(transform, glm::vec3(0.5f, 0.5f, 0.5f));GLuint transLoc = glGetUniformLocation(ourShader.Program, &quot;transform&quot;);glUniformMatrix4fv(transLoc, 1, GL_FALSE, glm::value_ptr(transform)); 各个变换的顺序有意义，后写的先执行！！！将值通过 uniform 形式传送给着色器，这样你可以在着色器使用 uniform mat4 transform 接收。 1234567891011121314// vectorShaderout vec3 ourColor;uniform mat4 transform;void main(){ gl_Position = transform * vec4(position, 1.0f); ourColor = vertexColor;} ​ Week 7-2在透视矩阵加持下，生成真正的正方体 你可以参考：【LearnOpenGL】坐标系统 | 进入 3D 12345// main.cppglm::mat4 projection = glm::perspective(glm::radians(90.0f), float(screenWidth) / float(screenHeight), 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;projection&quot;), 1, GL_FALSE, glm::value_ptr(projection)); 1234567891011121314151617181920// vectorShader#version 330 corelayout(location = 0) in vec3 position;layout(location = 1) in vec2 textCoord;out vec2 ourTextCoord;uniform mat4 transform;uniform mat4 projection;void main(){ gl_Position = projection * transform * vec4(position, 1.0f); // 注意顺序 ourTextCoord = vec2(textCoord.x, 1 - textCoord.y);} 各个变换的顺序有意义，后写的先执行！！！​ Week 8-1Camera.h 构造函数 你可以复习：c++ 带参构造函数与初始化列表 ​ 123456789101112Camera(glm::vec3 nPosition = DEFAULT_POSITION) : cameraPosition(nPosition), worldUp(DEFAULT_WORLD_UP), yaw(DEFAULT_YAW), pitch(DEFAULT_PITCH), movementSpeed(DEFAULT_SPEED), cameraFront(DEFAULT_CAMERA_FRONT), zoom(DEFAULT_ZOOM){ this-&gt;updateCameraVectors();} 12345678910111213// 以上使用初始化列表的写法等价于下面这种：Camera(glm::vec3 nPosition = DEFAULT_POSITION) { this-&gt;position = nPosition; this-&gt;worldUp = DEFAULT_WORLD_UP; this-&gt;yaw = DEFAULT_YAW; this-&gt;pitch = DEFAULT_PITCH; this-&gt;movementSpeed = DEFAULT_SPEED; this-&gt;cameraFront = DEFAULT_CAMERA_FRONT; this-&gt;zoom = DEFAULT_ZOOM; this-&gt;updateCameraVectors(); } 12345678910111213// 老师上课时的写法Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), GLfloat yaw = DEFAULT_YAW, GLfloat pitch = DEFAULT_PITCH) :cameraFront(glm::vec3(0.0f, 0.0f, -1.0f)), zoom(DEFAULT_ZOOM), movementSpeed(DEFAULT_SPEED) { this-&gt;position = position; this-&gt;worldUp = up; this-&gt;yaw = yaw; this-&gt;pitch = pitch; this-&gt;updateCameraVectors(); } 以上这三段代码实现的结果一致。​ 摄像机观察空间[ ](https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/) 你可以参考：【LearnOpenGL】摄像机 1234567891011121314// 摄像机坐标glm::vec3 position;// 世界坐标系下的一个向上（y）的方向向量，我们会定义它为（0，1，0）glm::vec3 worldUp;// front(`Direction` in the pic), camera axis Z, 相机坐标系的 Z 轴glm::vec3 cameraFront;// right, camera axis X, 相机坐标系的 X 轴glm::vec3 cameraRight;// up, camera axis Y, 相机坐标系的 Y 轴glm::vec3 cameraUp; 12345678910111213 void updateCameraVectors() { glm::vec3 front; front.x = cos(glm::radians(this-&gt;pitch)) * cos(glm::radians(this-&gt;yaw)); front.y = sin(glm::radians(this-&gt;pitch)); front.z = cos(glm::radians(this-&gt;pitch)) * sin(glm::radians(this-&gt;yaw)); this-&gt;cameraFront = glm::normalize(front); this-&gt;cameraRight = glm::normalize(glm::cross(this-&gt;cameraFront, this-&gt;worldUp)); this-&gt;cameraUp = glm::normalize(glm::cross(this-&gt;cameraRight, this-&gt;cameraFront)); }}; ​ this-&gt;cameraRight = glm::normalize(glm::cross(this-&gt;cameraFront, this-&gt;worldUp));和 LearnOpenGL 的教程有点不一样。是因为我们课程里的 camera front 设置为反方向，教程接下来就用了这种方法​ this-&gt;worldUp 的引入是因为只有相机坐标系的 z 方向是没办法确定 x 方向的，但是利用叉积的原理，我们并不需要准确的 y 方向，找一个在同一平面的作叉积就得到相同的结果，所以我们自然的选择了世界坐标系下的 y 方向向量。​ 使用矩阵的好处之一是如果你使用 3 个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这 3 个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是 LookAt 矩阵所做的，现在我们有了 3 个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的 LookAt 矩阵了： &gt; &gt; LookAt=[RxRyRz0UxUyUz0DxDyDz00001]∗[100−Px010−Py001−Pz0001] &gt; 其中 R 是右向量，U 是上向量，D 是方向向量 P 是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个 LookAt 矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt 矩阵就像它的名字表达的那样：它会创建一个看着 (Look at) 给定目标的观察矩阵。 我们首先将摄像机位置设置为之前定义的 cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新 cameraPos 向量。 1234glm::mat4 GetViewMatrix(){ return glm::lookAt(this-&gt;position, this-&gt;position + this-&gt;cameraFront, this-&gt;cameraUp);} ​ 键盘控制摄像机视角移动不同设备帧率不同，可能会导致移动速度不一样。我们利用时间一致，用时间来控制移动速度： 1234567891011121314151617181920void DoMovement(){ if (keys[GLFW_KEY_W] || keys[GLFW_KEY_UP]) { camera.ProcessKeyboard(FORWARD, deltaTime); } if (keys[GLFW_KEY_S] || keys[GLFW_KEY_DOWN]) { camera.ProcessKeyboard(BACKWARD, deltaTime); } if (keys[GLFW_KEY_A] || keys[GLFW_KEY_LEFT]) { camera.ProcessKeyboard(LEFT, deltaTime); } if (keys[GLFW_KEY_D] || keys[GLFW_KEY_RIGHT]) { camera.ProcessKeyboard(RIGHT, deltaTime); }} ​ ​ 123456789101112void ProcessMouseMovement(GLfloat xOffset, GLfloat yOffset){ xOffset *= this-&gt;mouseSensitivity; yOffset *= this-&gt;mouseSensitivity; this-&gt;yaw += xOffset; this-&gt;pitch += yOffset; this-&gt;updateCameraVectors();} 如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的 xpos 和 ypos 会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个 bool 变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为 xpos 和 ypos 值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了： 1234567891011void ProcessMouseMovement(GLfloat xOffset, GLfloat yOffset){ xOffset *= this-&gt;mouseSensitivity; yOffset *= this-&gt;mouseSensitivity; this-&gt;yaw += xOffset; this-&gt;pitch += yOffset; this-&gt;updateCameraVectors();} 当滚动鼠标滚轮的时候，yoffset 值代表我们竖直滚动的大小。当 scroll_callback 函数被调用后，我们改变全局变量 fov 变量的内容。因为 45.0f 是默认的视野值，我们将会把缩放级别 (Zoom Level) 限制在 1.0f 到 45.0f。 Week 8-2 &amp; Week 8-31234567891011121314151617181920212223242526/* 原立方体 */ourShader.Use();glm::mat4 transform = glm::mat4(1.0f);// transform = glm::translate(transform, glm::vec3(0.0f, 0.0f, -2.0f));transform = glm::rotate(transform, glm::radians(20.0f), glm::vec3(1.0f, 1.0f, 1.0f));// transform = glm::scale(transform, glm::vec3(0.5f, 0.5f, 0.5f));glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;transform&quot;), 1, GL_FALSE, glm::value_ptr(transform));glm::mat4 projection = glm::perspective(glm::radians(camera.GetZoom()), float(screenWidth) / float(screenHeight), 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;projection&quot;), 1, GL_FALSE, glm::value_ptr(projection));glm::mat4 view = camera.GetViewMatrix();glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;view&quot;), 1, GL_FALSE, glm::value_ptr(view));//glUniform3f(glGetUniformLocation(ourShader.Program, &quot;LightPos&quot;), lightPos.x, lightPos.y, lightPos.z);glUniform3f(glGetUniformLocation(ourShader.Program, &quot;ViewPos&quot;), camera.GetPosition().x, camera.GetPosition().y, camera.GetPosition().z);glUniform1f(glGetUniformLocation(ourShader.Program, &quot;material.diffuse&quot;), DIFFUSE);glUniform1f(glGetUniformLocation(ourShader.Program, &quot;material.specular&quot;), SPECULAR);//glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); 1234567891011121314151617/* 光源立方体 */lightShader.Use();glm::mat4 transformLight = glm::mat4(1.0f);lightPos = glm::rotate(lightPos, glm::radians(0.05f), glm::vec3(1.0f, 1.0f, 1.0f));transformLight = glm::translate(transformLight, lightPos);transformLight = glm::scale(transformLight, glm::vec3(0.1f, 0.1f, 0.1f));glUniformMatrix4fv(glGetUniformLocation(lightShader.Program, &quot;transform&quot;), 1, GL_FALSE, glm::value_ptr(transformLight));glm::mat4 projectionLight = glm::perspective(glm::radians(camera.GetZoom()), float(screenWidth) / float(screenHeight), 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(lightShader.Program, &quot;projection&quot;), 1, GL_FALSE, glm::value_ptr(projectionLight));glm::mat4 viewLight = camera.GetViewMatrix();glUniformMatrix4fv(glGetUniformLocation(lightShader.Program, &quot;view&quot;), 1, GL_FALSE, glm::value_ptr(viewLight));lightModel.Draw(); 除去光照部分的设置，两立方体的设置都是对称的格式！​ 思考：OpenGL z 轴方向问题OpenGL 中世界坐标系下，是遵循右手准则的。DX 中才是左手准则。​ 当我们转换到相机坐标系下后，OpenGl 会对坐标进行归一化处理（归一化设备坐标系 NDC）。这里有一个问题，NDC 是遵循左手准则的。​ 这在相机坐标系下，对归一化后的 NDC 来说，近的物体（z 轴）坐标值要小于远处的物体。而我们最开始定义 vertices 的时候，是按照世界坐标系定义的，如果我们没有处理，直接传给 NDC 坐标系，所以这会导致 z 轴设置的前后对称（相反）： 123456in vec3 aPos;void main(){ gl_Position = vec4(aPos, 1.0);} ​ ​ 一般的，解决方法是在将世界坐标系下的坐标传入 NDC 之前，我们会对其用投影矩阵转换输入的顶点： 1234567in vec3 aPos;mat4 modelProjectionMatrix;void main(){ gl_Position = modelProjectionMatrix * vec4(aPos, 1.0);} 参考：OpenGL Projection Matrix Note that both xp and yp depend on ze; they are inversely propotional to -ze. In other words, they are both divided by -ze. It is a very first clue to construct GL_PROJECTION matrix. After the eye coordinates are transformed by multiplying GL_PROJECTION matrix, the clip coordinates are still a homogeneous coordinates. It finally becomes the normalized device coordinates (NDC) by divided by the w-component of the clip coordinates. (See more details on OpenGL Transformation.) &gt; … &gt; Finally, we found all entries of GL_PROJECTION matrix. The complete projection matrix is; &gt; stackoverflow | opengl-z-value-why-negative-value-in-front Of course the red triangle is in front of the blue one, because you don’t use any projection matrix. You forgot to transform the input vertex by the projection matrix before you assign the vertex coordinate to gl_Position. &gt; This causes that the vertices are equal to the normalized device space coordinates. In normalized device space the z-axis points into the viewport and the “projection” is orthographic and not perspective. 简书：OpenGL NDC 左手还是右手 null CSDN | OpenGL 默认的 Z 轴方向问题 OpenGL 的 NDC 默认是左手坐标系（Z 轴正方向指向屏幕内侧），范围为（-1.0， 1.0）；OpenGL 的空间坐标系使用右手坐标系，Z 轴正方向指向屏幕外侧； &gt; 上面代码中传入的坐标没有经过变换（MVP），直接赋值作为最终的 NDC 坐标，因此展现了这种情况 GitHub | LearnOpenGL | 坐标系统 为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型 (Model)、观察 (View)、投影 (Projection) 三个矩阵。我们的顶点坐标起始于局部空间 (Local Space)，在这里它称为局部坐标 (Local Coordinate)，它在之后会变为世界坐标 (World Coordinate)，观察坐标 (View Coordinate)，裁剪坐标 (Clip Coordinate)，并最后以屏幕坐标 (Screen Coordinate) 的形式结束。 ​ Exercise第 1 次作业：矩形颜色交替变换方法 11234567891011121314151617181920212223/* main.cpp */// 逐帧画图 while (!glfwWindowShouldClose(window)) { glViewport(0, 0, screenWidth, screenHeight); glfwPollEvents(); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // 使用着色器绘制一个三角形 ourShader.Use(); // 作业 1 颜色交替 float time = glfwGetTime(); float colorValue = ( sin(time) / 2 ) + 0.5; glUniform1f(glGetUniformLocation(ourShader.Program, &quot;colorValue&quot;), colorValue); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glfwSwapBuffers(window); } float time = glfwGetTime();很大的值​ float colorValue = ( sin(time) / 2 ) + 0.5;写法不唯一，只是让 time 值变小，并且为正，使其在 0 到 1 变化（颜色范围边界是 0~1）​ glUniform1f(glGetUniformLocation(ourShader.Program, &quot;colorValue&quot;), colorValue);传送 1f 即 1 个 float​ 查询 uniform 地址不要求你之前使用过着色器程序，但是更新一个 uniform 之前你必须先使用程序（调用 glUseProgram)，因为它是在当前激活的着色器程序中设置 uniform 的。​ 123456789101112131415161718192021/* .fs */#version 330 coreout vec4 color;in vec3 vertexColor;uniform float colorValue;void main(){ color = vec4(vertexColor.x, vertexColor.y + colorValue, vertexColor.z, 1.0f);} uniform float colorValue;接收传送内容​ color = vec4(vertexColor.x, vertexColor.y + colorValue, vertexColor.z, 1.0f);colorValue 从 0~0.5 变化​ 此时由于预定义三角形颜色 vertexColor = (1, 0, 0) 红色color = (1, 0 + colorValue, 0) 在 (1, 0, 0)红色 和 (1, 1, 0) 橙色 之间变化. 方法 2传 vec4，这样的话原来传的值就被这里新定义的覆盖了 1glUniform4f(glGetUniformLocation(ourShader.Program, &quot;newVertexColor&quot;), 1.0f, colorValue, 0.0f, 1.0f); 12345678910111213141516/* .fs */#version 330 coreout vec4 color;in vec3 vertexColor;uniform vec4 newVertexColor;void main(){ color = vec4(newVertexColor);} 第 2 次作业：纹理替换 睿的要求：纹理变化常通过纹理平移来实现，所以不只是渐变，还要平移！ 123456789101112131415161718192021222324252627//// 作业 2 纹理交替变换 ---- BEG float time = glfwGetTime(); float translateValue = fmodf(time, 10.0f) / 10.0f; if (((int)time / 10) % 2) { glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture0); glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture0&quot;), 0); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture1); glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture1&quot;), 1); } else { glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture0); glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture0&quot;), 1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture1); glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture1&quot;), 0); } glUniform1f(glGetUniformLocation(ourShader.Program, &quot;translateValue&quot;), translateValue);//// 作业 2 纹理交替变换 ---- END if 语句的作用是使纹理始终沿一个方向变化。 1234567891011121314151617/* .vs */#version 330 corelayout(location = 2) in vec2 textCoord;out vec2 ourTextCoord;out float ourTranslateValue;uniform float translateValue;void main(){ ourTextCoord = vec2(textCoord.x, 1 - textCoord.y - translateValue); ourTranslateValue = translateValue;} 1234567891011121314/* .fs */#version 330 corein vec2 ourTextCoord;in float ourTranslateValue;void main(){ color = mix(texture(texture0, ourTextCoord), texture(texture1, ourTextCoord), ourTranslateValue);} 利用 mix() 实现渐变，最后一个参数是线性插值，[0,1] ，极端值分别取首个、第二个纹理。修改纹理坐标，使纹理移动。顺便利用这个变量 translateValue，进行线性插值，实现纹理的渐变转换。​ 第 3 次作业：地月模型 根据本次作业布置的时间，本次作业没有利用摄像机视角，没有利用光源模型。 ​ 12newPos = glm::rotate(newPos, glm::radians(0.1f), glm::vec3(1.0f, 1.0f, 0.0f));transform = glm::translate(transform, glm::vec3(newPos.x, newPos.y, newPos.z - 2)); glm::rotate 的第 3 个参数是根据从坐标原点 (0, 0, 0) 出发的向量的轴旋转的。由于我们设置了中心正方体的坐标在 (0, 0, -2)（因为此时人也在原点），所以我们需要把坐标在原点设置完自转效果，再通过 glm::rotate 移动到 (0, 0, -2)。​ ⚠ 注意：必须加上这个附加库的头文件使用：#include &lt;glm/gtx/rotate_vector.hpp&gt;​ 我重复利用同一个正方体的顶点数据 vertices[]，去生成大小位置不一样的两个正方体： 1234567891011121314151617181920212223242526272829303132ourShader.Use();glm::mat4 transform;glm::mat4 projection = glm::perspective(glm::radians(90.0f), float(screenWidth) / float(screenHeight), 0.1f, 100.0f);glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;projection&quot;), 1, GL_FALSE, glm::value_ptr(projection));/* 中心正方体（地球） */transform = glm::mat4(1.0f);transform = glm::translate(transform, glm::vec3(0.0f, 0.0f, -2.0f));transform = glm::rotate(transform, glm::radians(20.0f) * static_cast&lt;GLfloat&gt;(glfwGetTime()), glm::vec3(sin(23.5 * PI / 180), cos(23.5 * PI / 180), 0));transform = glm::scale(transform, glm::vec3(0.5f, 0.5f, 0.5f));glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;transform&quot;), 1, GL_FALSE, glm::value_ptr(transform));glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0);/* 旋转正方体（月球） */transform = glm::mat4(1.0f);newPos = glm::rotate(newPos, glm::radians(0.05f), glm::vec3(sin(23.5 * PI / 180), cos(23.5 * PI / 180) , 0));transform = glm::translate(transform, glm::vec3(newPos.x, newPos.y, newPos.z - 2));transform = glm::rotate(transform, glm::radians(20.0f) * static_cast&lt;GLfloat&gt;(glfwGetTime()), glm::vec3(sin(23.5 * PI / 180), cos(23.5 * PI / 180), 0));transform = glm::scale(transform, glm::vec3(0.1f, 0.1f, 0.1f));glUniformMatrix4fv(glGetUniformLocation(ourShader.Program, &quot;transform&quot;), 1, GL_FALSE, glm::value_ptr(transform));glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 36);glBindVertexArray(0); ​ 第 4 次作业：实现控制物体的移动引入物体坐标变量 ObjectPos。​ DoMovement() 函数针对物体坐标进行修改： 12345678910111213// 物体上下左右（↑/↓/←/→）移动 if (keys[GLFW_KEY_UP]) { ObjectPos.y += deltaTime * OBJECT_SPEED;}if (keys[GLFW_KEY_DOWN]) { ObjectPos.y -= deltaTime * OBJECT_SPEED;}if (keys[GLFW_KEY_LEFT]) { ObjectPos.x -= deltaTime * OBJECT_SPEED;}if (keys[GLFW_KEY_RIGHT]) { ObjectPos.x += deltaTime * OBJECT_SPEED;} 每次循环时应该更新物体的坐标，因为现在它可能在 DoMovement()中被修改了： 1transform = glm::translate(transform, ObjectPos);","link":"/2021/11/19/njupt-cg-opengl/"}],"tags":[],"categories":[]}