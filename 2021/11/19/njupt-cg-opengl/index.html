<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="&quot;referrer&quot; content"><meta><title>NJUPT-CG-OpenGL - tou&#039;s Website</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="tou&#039;s Website"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="tou&#039;s Website"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="由于疫情，南京邮电大学 2021-2022-1 的计算机图形学课程（课程代号：B0301312C ）采用了线上教学模式。鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 bilibili 弹幕网（BV1ib4y1Y74J）。此外，根据上课内容，我上传了在线授课过程中的代码（toulzx&amp;#x2F;NJUPT-CG-OpenGL）供大家参考。^本文目前仅在语雀、个人博客发布发布，内容为作者 tou 原"><meta property="og:type" content="article"><meta property="og:title" content="NJUPT-CG-OpenGL"><meta property="og:url" content="http://www.toulzx.top/2021/11/19/njupt-cg-opengl/"><meta property="og:site_name" content="tou&#039;s Website"><meta property="og:description" content="由于疫情，南京邮电大学 2021-2022-1 的计算机图形学课程（课程代号：B0301312C ）采用了线上教学模式。鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 bilibili 弹幕网（BV1ib4y1Y74J）。此外，根据上课内容，我上传了在线授课过程中的代码（toulzx&amp;#x2F;NJUPT-CG-OpenGL）供大家参考。^本文目前仅在语雀、个人博客发布发布，内容为作者 tou 原"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342070612-ccd0926c-34c2-47cc-9949-8a9c47f66e2e.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=451&amp;id=u2c6aaeb9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=601&amp;originWidth=1095&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=88543&amp;status=done&amp;style=none&amp;taskId=u55378cfa-61fc-4af2-87de-495fd8ccbb7&amp;title=&amp;width=821"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342569159-20ed7ac3-4723-4ef8-a3ee-e3d826feaa5e.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=ud7ee0e38&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=544&amp;originWidth=784&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=54848&amp;status=done&amp;style=none&amp;taskId=ucc4e7c2d-450d-474f-95c6-929365b78e7&amp;title=&amp;width=392"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342618356-c8623134-c4d6-46f9-a23a-b67db2525f12.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=269&amp;id=u1894b624&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=538&amp;originWidth=784&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=50291&amp;status=done&amp;style=none&amp;taskId=u0cc86814-04e6-43fe-acf3-9f34ad7781b&amp;title=&amp;width=392"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636343466676-8859c78a-d984-497c-94c4-041571b0b3e2.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=273&amp;id=u04c78cf1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=546&amp;originWidth=784&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=54222&amp;status=done&amp;style=none&amp;taskId=u3cd5f8af-8a79-4184-ad24-0a9f92fab0c&amp;title=&amp;width=392"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342779006-341318c9-01fc-4a1e-8ada-26c1e0579e77.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=272&amp;id=ua8299034&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=544&amp;originWidth=784&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=43515&amp;status=done&amp;style=none&amp;taskId=u4293b77f-cd97-4e08-a93f-b105475abc4&amp;title=&amp;width=392"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342853298-298e291f-c14e-42a8-8901-e5d4a635ecf2.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=271&amp;id=u55a8d1dc&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=784&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=50445&amp;status=done&amp;style=none&amp;taskId=u42b5ac77-94cf-4b5e-b732-a31903f73f0&amp;title=&amp;width=392"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636361643727-a4ee9e77-b39c-4840-925c-5421ce2b1b02.png#clientId=uee618c9d-6e88-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=n2xhf&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=176&amp;originWidth=697&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=16208&amp;status=done&amp;style=none&amp;taskId=u1d62eb10-6b3c-4b18-b0b2-47ab57fbe50&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636343599605-c28c7424-d6b3-4774-b50a-14a24cbba8ae.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=405&amp;id=u4bff268d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=809&amp;originWidth=1198&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=81034&amp;status=done&amp;style=none&amp;taskId=u18e380e8-b423-4b5d-b378-5afaddc027c&amp;title=&amp;width=599"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636372008289-c5e9e940-4e1b-4409-9d3c-25ae188fa693.png#clientId=u9a78e5eb-470d-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=612&amp;id=uaec5111b&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=612&amp;originWidth=712&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=217728&amp;status=done&amp;style=none&amp;taskId=u91b7e443-c574-4295-be99-525755b5973&amp;title=&amp;width=712"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636381916597-f6157ddd-31e0-4d6b-ab2e-657301532fdc.png#clientId=u2e147f70-96f8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=129&amp;id=u9babfd0c&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=129&amp;originWidth=224&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=3849&amp;status=done&amp;style=none&amp;taskId=u0fb62c23-7243-4d88-8942-a996957c661&amp;title=&amp;width=224"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636379241879-85f8d2c4-938e-44d0-b14a-af35e6fb87bd.png#clientId=u2e147f70-96f8-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=137&amp;id=uab8de6a4&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=137&amp;originWidth=695&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=10038&amp;status=done&amp;style=none&amp;taskId=u5f57b2e0-34bb-427a-8e13-a8b264a6849&amp;title=&amp;width=695"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1637322279453-2cdae910-7771-4d5c-a50c-21e8405c99c5.png#clientId=u6eb6f50e-38b4-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u89356a10&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=470&amp;originWidth=600&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=35600&amp;status=done&amp;style=none&amp;taskId=u1118c878-481c-4107-a108-1d9847df80c&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636467347509-2fa60359-1a82-458f-9e3f-3f66bb969194.png#clientId=ub485a623-7f5c-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=541&amp;id=u5c556179&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=541&amp;originWidth=784&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=55521&amp;status=done&amp;style=none&amp;taskId=u14946cdb-39c4-406d-9cb5-055fead5435&amp;title=&amp;width=784"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636793080478-8a032b0e-082e-46fe-8c3d-c190ef80573e.png#clientId=u0547b413-7070-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u5f47f61e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=175&amp;originWidth=800&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=22350&amp;status=done&amp;style=none&amp;taskId=u4a70bf1a-58b4-4e7e-b4ba-27df50e4da9&amp;title="><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636794661074-c9c8dccd-fac2-4b1f-892b-b8712407a5c1.png#clientId=u0547b413-7070-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=163&amp;id=u1589c720&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=163&amp;originWidth=546&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=10840&amp;status=done&amp;style=none&amp;taskId=u91f56aa1-8349-4ee4-9098-4cff3c1bb0b&amp;title=&amp;width=546"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636720432429-6052b751-8512-4ed2-b286-a90d00e9ad02.png#clientId=u042d757e-e23a-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=90&amp;id=LhZEE&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=372&amp;originWidth=516&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=15759&amp;status=done&amp;style=none&amp;taskId=u17d87bf1-7a4f-4ef2-aafa-8e4c4249ed0&amp;title=&amp;width=124.671875"><meta property="article:published_time" content="2021-11-19T09:58:29.000Z"><meta property="article:modified_time" content="2021-12-10T02:09:14.792Z"><meta property="article:author" content="tou"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342070612-ccd0926c-34c2-47cc-9949-8a9c47f66e2e.png#clientId=u55a8458a-d43b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=451&amp;id=u2c6aaeb9&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=601&amp;originWidth=1095&amp;originalType=binary%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=88543&amp;status=done&amp;style=none&amp;taskId=u55378cfa-61fc-4af2-87de-495fd8ccbb7&amp;title=&amp;width=821"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.toulzx.top/2021/11/19/njupt-cg-opengl/"},"headline":"NJUPT-CG-OpenGL","image":[],"datePublished":"2021-11-19T09:58:29.000Z","dateModified":"2021-12-10T02:09:14.792Z","author":{"@type":"Person","name":"tou"},"publisher":{"@type":"Organization","name":"tou's Website","logo":{"@type":"ImageObject","url":{"text":"tou's Website"}}},"description":"由于疫情，南京邮电大学 2021-2022-1 的计算机图形学课程（课程代号：B0301312C ）采用了线上教学模式。鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 bilibili 弹幕网（BV1ib4y1Y74J）。此外，根据上课内容，我上传了在线授课过程中的代码（toulzx&#x2F;NJUPT-CG-OpenGL）供大家参考。^本文目前仅在语雀、个人博客发布发布，内容为作者 tou 原"}</script><link rel="canonical" href="http://www.toulzx.top/2021/11/19/njupt-cg-opengl/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code&amp;family=Noto+Sans+SC:wght@400;700"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">tou&#039;s Website</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">Archives</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-11-19T09:58:29.000Z" title="2021-11-19 5:58:29 ├F10: PM┤">2021-11-19</time>发表</span><span class="level-item"><time dateTime="2021-12-10T02:09:14.792Z" title="2021-12-10 10:09:14 ├F10: AM┤">2021-12-10</time>更新</span><span class="level-item">1 小时读完 (大约10246个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">NJUPT-CG-OpenGL</h1><meta name="referrer" content="no-referrer"><div class="content"><blockquote>
<p>由于疫情，南京邮电大学 <code>2021-2022-1</code> 的<strong>计算机图形学</strong>课程（课程代号：<em>B0301312C</em> ）采用了线上教学模式。<br>鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 <strong>bilibili 弹幕网</strong>（<a target="_blank" rel="noopener" href="https://b23.tv/sBmpt8E">BV1ib4y1Y74J</a>）。此外，根据上课内容，我上传了在线授课过程中的代码（<a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL">toulzx/NJUPT-CG-OpenGL</a>）供大家参考。<br><em>^本文目前仅在</em><a target="_blank" rel="noopener" href="https://www.yuque.com/toulzx/website-sync/yuque-github-hexo"><em>语雀</em></a><em>、</em><a target="_blank" rel="noopener" href="https://toulzx.github.io/"><em>个人博客</em></a><em>发布发布，内容为作者 tou 原创，不允许转载。谢谢！</em></p>
</blockquote>
<span id="more"></span>

<h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文目前仅在<a target="_blank" rel="noopener" href="https://www.yuque.com/toulzx/website-sync/yuque-github-hexo">语雀</a>、<a target="_blank" rel="noopener" href="https://toulzx.github.io/">个人博客</a>发布发布，内容为作者 tou 原创，不允许转载。谢谢！</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于疫情，南京邮电大学 <code>2021-2022-1</code> 的<strong>计算机图形学</strong>课程（课程代号：<em>B0301312C</em> ）采用了线上教学模式。</p>
<p>鉴于这门课程的内容有一定难度，我已将课程回放保存并上传 <strong>bilibili 弹幕网</strong>（<a target="_blank" rel="noopener" href="https://b23.tv/sBmpt8E">BV1ib4y1Y74J</a>）。此外，根据上课内容，我上传了在线授课过程中的代码（<a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL">toulzx/NJUPT-CG-OpenGL</a>）供大家参考。<br>​</p>
<h2 id="如何食用"><a href="#如何食用" class="headerlink" title="如何食用"></a>如何食用</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul>
<li>文件夹 <code>Source</code><ul>
<li>文件夹 <code>HelloCG</code>：此项目文件夹</li>
<li>一些文件 <code>.PDFs</code>：功能库配置教程</li>
</ul>
</li>
<li>一些文件 <code>.ZIPs</code>：功能库</li>
</ul>
<p>​</p>
<h3 id="查阅历次代码及差异"><a href="#查阅历次代码及差异" class="headerlink" title="查阅历次代码及差异"></a>查阅历次代码及差异</h3><p>我按照课程教学顺序，将历次课程代码提交到此仓库下。</p>
<p><code>test_4</code> 分支的<a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/commit/65f6459491966bc9d3d7b68b8fe9ffbe4d46ba11">最新一次 commit 内容</a>是本课程的最后一次作业（第 4 次作业），它是基于最后一次课程的代码内容。由于此分支包含了所有课程的代码内容的 commits，因此我将此分支设置为默认分支。</p>
<p>此外，此前另外 3 次作业的代码不在课程教学内容中，因此我额外创建了 <code>test_3</code> 、<code>test_2</code> 、<code>test_1</code> 分支，他们是从默认分支的某次课程内容延伸出去的。</p>
<p>你可以点击仓库主页的 <a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/commits/test_4">commits</a>，这可以阅览历次 commit 的信息， 当你点击 <a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/commit/ebd13441c8ac2de793d20d961ef16babb355a12a">某次 commit 的标题</a> 时，你可查看和上一次 commit 内容的差异，我认为这可能会方便大家查看历次课程代码的差异。</p>
<p>⚠ 注意：这样的做法是我的首次尝试，有些 commits 的差异由于失误并不能正确预览，我会在出现这种情况的 <code>commit 差异</code>页面提供批注。当然，你完全可以不参考 <code>commit 差异</code>，你仍然可以下载运行可使用的的历次课程代码（见下）。<br>​</p>
<h2 id="历次课程代码"><a href="#历次课程代码" class="headerlink" title="历次课程代码"></a>历次课程代码</h2><h3 id="文件夹目录链接"><a href="#文件夹目录链接" class="headerlink" title="文件夹目录链接"></a>文件夹目录链接</h3><p>当你点开任意课程代码对应的 commit 链接后，即可查看相应课程内容对应的代码文件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/20743bb4fec727e91931253ce48461f96af195f7"><strong>Week2-1</strong> 初始环境配置和 Demo 测试</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/dc70d77b6df79eb13c22d53ca1cc291f37653c03"><strong>Week2-1</strong> 梳理、重写 Demo</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/cf9c8fa6320f602795f934063711457f4182518b"><strong>Week2-2</strong> &amp; <strong>Week3-1</strong> 使用着色器绘制一个三角形</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/83873486f750f92217054f8fa3e94f2f2bc60d19"><strong>Week3-2</strong> 优化代码结构，将着色器部分代码独立存放</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/e804677964a41f685bb35473bc51e9c2b435ba55"><strong>Week4-1</strong> 为三角形各个顶点设置不同的颜色</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/781216ef3c6c7f803eaadc9b6bafa9e62a3ee342"><strong>Week4-1</strong> 使用两个三角形拼成正方型</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/473bd6032d7f0cf8abcfe6ecb5b58d93202d88c3"><strong>Week4-1</strong> <strong>Exercise1</strong> 实现矩形颜色交替变换</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/75e411d6e863007e5a90a2cb76410e4045b97491"><strong>Week5-1</strong> 改用点和连接信息绘制正方形</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/6ec1a01707344ef61b6bd6de9fe1f65c45a2b8b1"><strong>Week5-1</strong> 清理代码，准备学习纹理部分</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/d84729346f00a6871e77d82a9ef770998fdef687"><strong>Week5-1</strong> 配置 SOIL2</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/da3f7eb056b194211ea83619d49c0c9062bf30aa"><strong>Week5-2</strong> 尝试纹理贴图</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/4294601f92242a5cd2ed4f625f0827219d60f455"><strong>Week5-2</strong> <strong>Exercise2</strong> 使纹理单方向渐变移动</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/453b96c88eb3ec4112154cb1507f195ed21b4abf"><strong>Week6-1</strong> 配置 GLM 库；清理代码，去除纹理部分，back to Week4-1</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/dbba0ac799630798118515fbed18781e78eaab4a"><strong>Week7-1</strong> 正方体的缩放、旋转、平移</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/f09f6f81aa9948fef253d12f108026a46ce56602"><strong>Week7-2</strong>通过透视投影生成真正的正方体</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/337b9d6d357fb4ffbe7f7ccdc20f767348d84bcf"><strong>Week7-2</strong> <strong>Exercise3</strong> 地月模型旋转（近似圆轨道 + 23.5°）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/8c280566820e7289abf5d4a7a9b1089bac89033d"><strong>Week8-1</strong> 实现摄像机（即观察者）视角的移动（w/a/s/d）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/1f0d24d7eb2a9c212b81fb968083a1463ba9cf46"><strong>Week8-1</strong> 实现摄像机视角移动的鼠标和滚轮事件</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/ebd13441c8ac2de793d20d961ef16babb355a12a"><strong>Week8-2</strong> &amp; <strong>Week8-3</strong> 实现旋转光源照射物体的效果</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/65f6459491966bc9d3d7b68b8fe9ffbe4d46ba11"><strong>Week8-3</strong> <strong>Exercise4</strong> &amp; <strong>fix</strong> 实现控制物体的（↑/↓/←/→）移动 &amp;&amp; 修复 x 轴光照位置的错误</a></li>
</ul>
<p>​</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>你可以通过 <code>Git</code> 直接将项目 clone 到本地，然后借助编辑器内置的 Git 管理工具即可轻松切换历次版本。<br>如果你看不懂上面这一行我在说什么，你可以拷贝链接到 <a target="_blank" rel="noopener" href="https://minhaskamal.github.io/DownGit/#/home">DownGit</a> 下载。</p>
<h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><h3 id="关于教程"><a href="#关于教程" class="headerlink" title="关于教程"></a>关于教程</h3><p>我推荐你学习这篇教程：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/"><strong>LearnOpenGL</strong></a>，你会发现此课程（特指 2021-2022 学年第 1 学期的线上课程）的授课思路参考了这份教程。<br>​</p>
<h3 id="课程笔记-amp-代码"><a href="#课程笔记-amp-代码" class="headerlink" title="课程笔记 &amp; 代码"></a>课程笔记 &amp; 代码</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Wang_Dou_Dou_/article/details/121240714">【CSDN】OpenGL 初学者入门——学习指南</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45668594/category_11435461.html">【CSDN】南邮计算机图形学实验报告</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/GodWuzZ/Graphics">【GitHub】 GodWuzZ/Graphics</a></li>
<li><a href="#bt58x">【yuque】tou/NJUPT-CG-OpenGL</a></li>
</ul>
<h2 id="一点建议"><a href="#一点建议" class="headerlink" title="一点建议"></a>一点建议</h2><p><strong>不要未经思考直接 copy 代码。</strong></p>
<p>首先，这对你学习这门课程没有好处；其次，睿检查作业的时候，会查看你的代码并询问细节。<em>（不要尝试在睿的雷区蹦迪，你真的会后悔的）</em></p>
<h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><h2 id="Week-2-1"><a href="#Week-2-1" class="headerlink" title="Week 2-1"></a>Week 2-1</h2><h3 id="初始环境配置"><a href="#初始环境配置" class="headerlink" title="初始环境配置"></a>初始环境配置</h3><blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/legacy/">【LearnOpenGL】编译和链接 GLEW</a></p>
</blockquote>
<p>​</p>
<h4 id="配置附加库目录，并使用静态链接的方式引用"><a href="#配置附加库目录，并使用静态链接的方式引用" class="headerlink" title="配置附加库目录，并使用静态链接的方式引用"></a>配置附加库目录，并使用静态链接的方式引用</h4><p>你需要下载本课程会使用到的附加库，并把它放在指定位置（你可以直接使用我<a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/tree/20743bb4fec727e91931253ce48461f96af195f7">仓库中上传的库</a>）：</p>
<h4 id="在项目属性配置中，将附加库的目录添加进来"><a href="#在项目属性配置中，将附加库的目录添加进来" class="headerlink" title="在项目属性配置中，将附加库的目录添加进来"></a>在项目属性配置中，将附加库的目录添加进来</h4><h5 id="step1"><a href="#step1" class="headerlink" title="step1:"></a>step1:</h5><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342070612-ccd0926c-34c2-47cc-9949-8a9c47f66e2e.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=451&id=u2c6aaeb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=1095&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=88543&status=done&style=none&taskId=u55378cfa-61fc-4af2-87de-495fd8ccbb7&title=&width=821" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342569159-20ed7ac3-4723-4ef8-a3ee-e3d826feaa5e.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=ud7ee0e38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=784&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=54848&status=done&style=none&taskId=ucc4e7c2d-450d-474f-95c6-929365b78e7&title=&width=392" alt="image.png"></p>
<h5 id="step2"><a href="#step2" class="headerlink" title="step2:"></a>step2:</h5><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342618356-c8623134-c4d6-46f9-a23a-b67db2525f12.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=269&id=u1894b624&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=784&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=50291&status=done&style=none&taskId=u0cc86814-04e6-43fe-acf3-9f34ad7781b&title=&width=392" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636343466676-8859c78a-d984-497c-94c4-041571b0b3e2.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=273&id=u04c78cf1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=546&originWidth=784&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=54222&status=done&style=none&taskId=u3cd5f8af-8a79-4184-ad24-0a9f92fab0c&title=&width=392" alt="image.png"></p>
<h5 id="step3"><a href="#step3" class="headerlink" title="step3:"></a>step3:</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opengl32.lib</span><br><span class="line">glew32s.lib</span><br><span class="line">glfw3.lib</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342779006-341318c9-01fc-4a1e-8ada-26c1e0579e77.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=272&id=ua8299034&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=784&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=43515&status=done&style=none&taskId=u4293b77f-cd97-4e08-a93f-b105475abc4&title=&width=392" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636342853298-298e291f-c14e-42a8-8901-e5d4a635ecf2.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=271&id=u55a8d1dc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=784&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=50445&status=done&style=none&taskId=u42b5ac77-94cf-4b5e-b732-a31903f73f0&title=&width=392" alt="image.png"><br>​</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ol>
<li><code>glfw</code> 配置链接器的附加库目录的时候注意根据 <code>Visual Studio</code> 版本选择。</li>
<li>建议统一使用 32 位。</li>
</ol>
<p>​</p>
<h4 id="在测试代码中引用附加库目录"><a href="#在测试代码中引用附加库目录" class="headerlink" title="在测试代码中引用附加库目录"></a>在测试代码中引用附加库目录</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GLEW 采用静态编译的方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLEW_STATIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="comment">//GLFW</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>#define GLEW_STATIC</code>：如果存在则优先使用静态库。<br><code>#include &lt;GL/glew.h&gt;</code>： 就是这张图中的路径：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636361643727-a4ee9e77-b39c-4840-925c-5421ce2b1b02.png#clientId=uee618c9d-6e88-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=n2xhf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=176&originWidth=697&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16208&status=done&style=none&taskId=u1d62eb10-6b3c-4b18-b0b2-47ab57fbe50&title=" alt="image.png"><br>同理 <code>glfw</code>.<br>​</p>
<p>当你正确添加了附加库目录后，以上代码段编辑器不会标红报错。<br>​</p>
<p>然后你可以尝试使用 DEMO 测试运行：<br>👉 <a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/blob/20743bb4fec727e91931253ce48461f96af195f7/Source/HelloCG/main.cpp">测试 demo 的代码</a><br>​</p>
<p>测试效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636343599605-c28c7424-d6b3-4774-b50a-14a24cbba8ae.png#clientId=u55a8458a-d43b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=405&id=u4bff268d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=809&originWidth=1198&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=81034&status=done&style=none&taskId=u18e380e8-b423-4b5d-b378-5afaddc027c&title=&width=599" alt="image.png"></p>
<h3 id="重写-Demo"><a href="#重写-Demo" class="headerlink" title="重写 Demo"></a>重写 Demo</h3><p><code>const GLint WIDTH = 800, HEIGHT = 600;</code><br>窗口大小定义为常量。<br><code>GLint</code> 前缀 GL 表示 OpenGL 支持的数据类型（支持 C、C++ 所有基本数据类型，只不过要增加前缀）<br>OpenGL 主要使用 <code>int</code> <code>unsignedInt</code> <code>float</code> （显卡用不到 double 类型，资源浪费，我们需要在不损失性能的情况下拥有最快速度）。<br>​</p>
<p><code>glfwInit()</code><br>初始化.<br>函数命名方式有特点 ： 小写库名+函数名<br>​</p>
<p><code>glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</code><br><code>glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</code><br>属性.<br>glfw 主副版本号设置：3.3<br>​</p>
<p><code>glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</code><br>属性.<br>窗口用途：画 OpenGL ，使用版本： <code>CORE OpenGL</code><br>​</p>
<p><code>glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</code><br>属性.<br>使其向前兼容 (Mac 必须写，Win 系统已经默认了）<br>​</p>
<p><code>glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);</code><br>属性.<br>不允许改变窗口大小，会影响投影、透视的情况.<br>​</p>
<p><code>GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Learn OpenGL&quot;, nullptr, nullptr);</code><br>GLFW 固定变量命名方式特点： 大写库名+变量名.<br>宽、高、标题、全屏、多屏<br>​</p>
<p><code>int screenWidth, screenHeight;</code><br><code>glfwGetFramebufferSize(window, &amp;screenWidth, &amp;screenHeight);</code><br>获得显存下实际窗口大小.<br>屏幕硬件可能导致显示的每 1 个像素的硬件构成不止 1 个，由于屏幕显示直接映射在显存上，这种情况下显存空间大于屏幕显示的空间尺寸.<br>​</p>
<p><code>glfwMakeContextCurrent(window);</code><br>设置焦点为当前窗口<br>​</p>
<p><code>glewExperimental = GL_TRUE;</code><br>必须设置的参数<br>怪异的保留变量，函数的命名方式，变量的赋值</p>
<p><code>glViewport(0, 0, screenWidth, screenHeight);</code><br>视口.<br>左下角坐标、显存空间的宽高，这里明显填满了整个窗口<br>​</p>
<p><code>glfwPollEvents();</code><br>获取标志信息.<br>比如：鼠标、键盘使用信息，都会被标志（Week 2-1 还用不到）<br>​</p>
<p><code>glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);</code><br>初始化一个颜色.<br>颜色用浮点数表示，如果有 alpha 值就不压缩<br>​</p>
<p><code>glClear(GL_COLOR_BUFFER_BIT);</code><br>用此颜色清理缓存区，进行初始化赋值操作（设置背景色）<br>​</p>
<p><code>glfwSwapBuffers(GLFWwindow* window); </code><br>双缓存机制.<br>当传输当前帧时，利用这个时间加载下一帧（创建空间绘制下一帧）<br>​</p>
<p>​</p>
<h2 id="Week-2-2-amp-Week-3-1"><a href="#Week-2-2-amp-Week-3-1" class="headerlink" title="Week 2-2 &amp; Week 3-1"></a>Week 2-2 &amp; Week 3-1</h2><h3 id="顶点着色器（Vector-Shader）"><a href="#顶点着色器（Vector-Shader）" class="headerlink" title="顶点着色器（Vector Shader）"></a>顶点着色器（Vector Shader）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">gl_Position = <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#version 330 core</code><br>类似 <code>core profile</code> 含义，版本号 3.3<br>​</p>
<p><code>layout(location = 0) in vec3 position;</code><br>如何从显存获取并映射变量.<br>变量 <code>position</code> .<br>三个浮点数构成的向量 <code>vec3</code>.<br>从显存硬件区域直接获取 <code>in</code>.<br>​</p>
<p><code>gl_Position = vec4(position, 1.0f);</code><br>最终顶点信息.<br><code>gl_Position</code> 预保留变量，四维信息.<br>​</p>
<h3 id="片元着色器（Fragment-Shader）"><a href="#片元着色器（Fragment-Shader）" class="headerlink" title="片元着色器（Fragment Shader）"></a>片元着色器（Fragment Shader）</h3><p>大部分情况等同 像素着色器 <code>Pixels Shader</code><br>有时候 1 个像素被不同着色器覆盖绘制多次，片源的描述更准确。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 color;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color = <span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);		<span class="comment">// 使他偏橙色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>color = vec4(1.0f, 0.5f, 0.2f, 1.0f);</code><br>颜色四维.<br>对每个片源进行颜色赋值.<br>​</p>
<h3 id="导入并编译着色器"><a href="#导入并编译着色器" class="headerlink" title="导入并编译着色器"></a>导入并编译着色器</h3><p><code>GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);</code><br>创建着色器对象.<br>​</p>
<p><code>glShaderSource(vertexShader, 1, &amp;vertexShaderCode, NULL);</code><br>把代码存入，传 1 个，代码，起始位置 NULL（整个传）.<br>​</p>
<p><code>glCompileShader(vertexShader);</code><br>编译.<br>生成目标代码也在 <code>vertexShader</code> 了<br>里面东西很多了：源代码、编译过程状态、失败日志、成功标志位、编译结果.<br>​</p>
<p>​</p>
<p><code>glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</code><br>后缀<code>iv</code> ：能够获取的返回参数的数据类型 integer &amp; vertex<br><code>COMPILE_STATUS</code> ： 这里是编译状态的标志位<br><code>success</code>： 存放编译状态信息<br>​</p>
<h3 id="创建并链接可执行文件"><a href="#创建并链接可执行文件" class="headerlink" title="创建并链接可执行文件"></a>创建并链接可执行文件</h3><p>略<br>​</p>
<h3 id="屏幕坐标系"><a href="#屏幕坐标系" class="headerlink" title="屏幕坐标系"></a>屏幕坐标系</h3><p>​</p>
<blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#3d">【LearnOpenGL】坐标系统 | 进入 3D</a></p>
</blockquote>
<p>​</p>
<p>OpenGL 采用右手坐标系：z 朝外为正，x 右，y 上<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636372008289-c5e9e940-4e1b-4409-9d3c-25ae188fa693.png#clientId=u9a78e5eb-470d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=612&id=uaec5111b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=612&originWidth=712&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=217728&status=done&style=none&taskId=u91b7e443-c574-4295-be99-525755b5973&title=&width=712" alt="image.png"></p>
<h3 id="传入数据到显卡"><a href="#传入数据到显卡" class="headerlink" title="传入数据到显卡"></a>传入数据到显卡</h3><blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">【LearnOpenGL】你好，三角形</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] =</span><br><span class="line">&#123;	<span class="comment">// position</span></span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.0f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶点正面对象（VAO）、顶点缓存对象（VBO）</span></span><br><span class="line">GLuint VAO, VBO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 VAO、VBO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据传入显卡</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in"><span class="keyword">sizeof</span></span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 VAO</span></span><br><span class="line"><span class="comment">// 对应此句：&quot;layout(location = 0) in vec3 position;&quot; 和上述 vertices[]</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat), (GLvoid*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑定 VAO、VBO</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>着色器不接收多余输入<br><code>VAO</code> 顶点正面对象：解释数据<br><code>VBO</code> 顶点缓存对象：传输数据，说明在显存空间上位置<br>他们一定成对出现！<br>绑定，先 a 后 b<br>​</p>
<p><code>glBindBuffer(GL_ARRAY_BUFFER, VBO);</code><br>在显卡上确定一段区域作为目的地.<br>​</p>
<p><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code><br>设置标志位 <code>static</code> 表示常读不常写，这样显存会寻找合适位置分配.<br>​</p>
<p><code>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);</code></p>
<ul>
<li>位置 0</li>
<li>3 个浮点数： 对应 <code>vec3</code> （float）</li>
<li>从 <code>vertices[]</code> 起始位取 ：<code>(GLvoid*)0</code></li>
<li>不需要对顶点标准化处理（-1 到 1 之间）： <code>GL_FALSE </code></li>
<li>每次取 3 个</li>
</ul>
<p>​</p>
<h3 id="调用着色器"><a href="#调用着色器" class="headerlink" title="调用着色器"></a>调用着色器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>glUseProgram(shaderProgram);</code><br>绑定着色器<br>​</p>
<p><code>glDrawArrays(GL_TRIANGLES, 0, 3);</code><br><code>position</code> 从 0 开始，画 3 个顶点（两个三角形就是 6 个）<br>​</p>
<h2 id="Week-3-2"><a href="#Week-3-2" class="headerlink" title="Week 3-2"></a>Week 3-2</h2><p>​</p>
<h3 id="关于-Visual-Studio-的“解决方案资源管理器”"><a href="#关于-Visual-Studio-的“解决方案资源管理器”" class="headerlink" title="关于 Visual Studio 的“解决方案资源管理器”"></a>关于 Visual Studio 的“解决方案资源管理器”</h3><p>​</p>
<p>添加文件注意，这里是逻辑添加，不一定对应实际文件夹路径：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636381916597-f6157ddd-31e0-4d6b-ab2e-657301532fdc.png#clientId=u2e147f70-96f8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=129&id=u9babfd0c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=129&originWidth=224&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3849&status=done&style=none&taskId=u0fb62c23-7243-4d88-8942-a996957c661&title=&width=224" alt="image.png"><br>​</p>
<p>建议先本地建好文件，对应添加进来：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636379241879-85f8d2c4-938e-44d0-b14a-af35e6fb87bd.png#clientId=u2e147f70-96f8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=137&id=uab8de6a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=137&originWidth=695&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10038&status=done&style=none&taskId=u5f57b2e0-34bb-427a-8e13-a8b264a6849&title=&width=695" alt="image.png"></p>
<h3 id="关于着色器的文件后缀"><a href="#关于着色器的文件后缀" class="headerlink" title="关于着色器的文件后缀"></a>关于着色器的文件后缀</h3><p><code>.fs</code> 、<code>.vs</code> 只是我们为了方便区分顶点着色器和片源着色器而进行个性化命名的。<br>​</p>
<p>事实上，在 <code>Week 2-2 &amp; Week 3-1</code> 课程中，甚至是本次课程 <code>Week 3-2</code> 你就可能注意到，我们对顶点着色器和片源着色器的引用是通过调用这部分的代码的字符串内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GLchar* vShaderCode = vertexCode.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="keyword">const</span> GLchar* fShaderCode = fragmentCode.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>

<h3 id="防止头文件重复引用"><a href="#防止头文件重复引用" class="headerlink" title="防止头文件重复引用"></a>防止头文件重复引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Shader_h		<span class="comment">// Shader.h 是文件名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Shader_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Week-4-1"><a href="#Week-4-1" class="headerlink" title="Week 4-1"></a>Week 4-1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat), (GLvoid*)(<span class="number">3</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat)));</span><br></pre></td></tr></table></figure>

<p>注意这里是 <code>3*sizeof(GLfloat)</code><br>改变各个顶点颜色，要向顶点着色器中新传递颜色信息，并且要传给片元着色器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertexShader</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 vertexColor;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fragmentShader</span></span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line">color = <span class="built_in">vec4</span>(ourColor, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<p>效果：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1637322279453-2cdae910-7771-4d5c-a50c-21e8405c99c5.png#clientId=u6eb6f50e-38b4-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u89356a10&margin=%5Bobject%20Object%5D&name=image.png&originHeight=470&originWidth=600&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=35600&status=done&style=none&taskId=u1118c878-481c-4107-a108-1d9847df80c&title=" alt="image.png"><br>我们设置了三个顶点的颜色，为什么中间的颜色会相互融合？这里涉及到了栅格化的知识：</p>
<blockquote>
<p>这个图片可能不是你所期望的那种，因为我们只提供了 3 个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓片段插值 (Fragment Interpolation) 的结果。当渲染一个三角形时，光栅化 (Rasterization) 阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。<br>基于这些位置，它会插值 (Interpolate) 所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的 70% 的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是 30% 蓝 + 70% 绿。<br>这正是在这个三角形中发生了什么。我们有 3 个顶点，和相应的 3 个颜色，从这个三角形的像素来看它可能包含 50000 左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。<br><em>^以上内容引用自</em><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">【LearnOpenGL】着色器</a></p>
</blockquote>
<p>​</p>
<h3 id="使用两个三角形拼成正方形"><a href="#使用两个三角形拼成正方形" class="headerlink" title="使用两个三角形拼成正方形"></a>使用两个三角形拼成正方形</h3><p>​</p>
<p>矩形的实现通过两个三角形合成.<br>仔细看坐标其实我们要生成的是正方形，但是展示的结果是长方形，这个跟我们窗口长宽有关。<br>​</p>
<p>我们主要修改了这部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点位置集 rectangle</span></span><br><span class="line">GLfloat vertices[] =</span><br><span class="line">&#123;	<span class="comment">// position						// color</span></span><br><span class="line">	<span class="comment">// first triangle</span></span><br><span class="line">	 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,			 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,			 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	<span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,			 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// second triangle</span></span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,			 <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,			 <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span>,</span><br><span class="line">	<span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,			 <span class="number">0.0f</span>,  <span class="number">1.0f</span>,  <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记得修改：<code>glDrawArrays(GL_TRIANGLES, 0, 6);</code>，我们使用了 6 个顶点绘制两个三角形了。<br>​</p>
<p>​</p>
<h2 id="Week-5-1"><a href="#Week-5-1" class="headerlink" title="Week 5-1"></a>Week 5-1</h2><h3 id="改用点和连接信息构建正方形"><a href="#改用点和连接信息构建正方形" class="headerlink" title="改用点和连接信息构建正方形"></a>改用点和连接信息构建正方形</h3><blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_10">【LearnOpenGL】你好，三角形 | 索引缓冲对象（EBO）</a></p>
</blockquote>
<p>​</p>
<p>单纯用点来构成物体，当物体多样了，点多了，复杂度高<br>我们使用点和连接信息来构建物体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义点和颜色</span></span><br><span class="line">GLfloat vertices[] =</span><br><span class="line">&#123;	<span class="comment">// position							// color</span></span><br><span class="line">	 <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,				 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,		<span class="comment">// 右上</span></span><br><span class="line">	 <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,				 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,		<span class="comment">// 右下</span></span><br><span class="line">	<span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,				 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,		<span class="comment">// 左下</span></span><br><span class="line">	<span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>,				 <span class="number">1.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>,		<span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义连接信息</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,				<span class="comment">// 第一个三角形</span></span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>					<span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>连接信息使用 <code>EBO</code>（elemental buffer object 元素缓冲对象）生成绑定。<br>​</p>
<p>VAO、VBO 一定成对出现<br>但连接信息 EBO 并不是，随时可变。<br>​</p>
<p><code>glDrawArrays(GL_TRIANGLES, 0, 6);</code><br>while 中 此句不再适用了<br><code>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code><br>改用此句<br>​</p>
<p>​</p>
<h3 id="配置-SOIL2"><a href="#配置-SOIL2" class="headerlink" title="配置 SOIL2"></a>配置 SOIL2</h3><blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://github.com/toulzx/NJUPT-CG-OpenGL/blob/d84729346f00a6871e77d82a9ef770998fdef687/Source/OpenGL%20SOIL2.pdf">OpenGL SOIL2.pdf</a></p>
</blockquote>
<p>根据参考链接做即可，项目中的配置方法和以前差不多，不过此处只需要添加一处附加库目录即可：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636467347509-2fa60359-1a82-458f-9e3f-3f66bb969194.png#clientId=ub485a623-7f5c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=541&id=u5c556179&margin=%5Bobject%20Object%5D&name=image.png&originHeight=541&originWidth=784&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=55521&status=done&style=none&taskId=u14946cdb-39c4-406d-9cb5-055fead5435&title=&width=784" alt="image.png"></p>
<h2 id="Week-5-2"><a href="#Week-5-2" class="headerlink" title="Week 5-2"></a>Week 5-2</h2><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纠正一个网络上普遍的错误：<br>OpenGL 推荐 <code>2^n</code> 的纹理，但不是强制的，它只是有利于生成多层渐进纹理。非 <code>2^n</code> 只是无法生成 <code>mipmap</code>（多层渐进纹理）。</p>
<blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures">【LearnOpenGL】纹理 | 纹理的环绕方式</a></p>
</blockquote>
<p><code>glBindTexture(GL_TEXTURE_2D, texture);</code><br>二维纹理：广泛被使用，图片</p>
<p><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</code><br><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code><br>S、T、R（维度），对应 x、y、z（轴）</p>
<p><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</code><br>当纹理大于物体时候的设置<br><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</code>​<br>当纹理小于物体时候的设置<br>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* image = <span class="built_in">SOIL_load_image</span>(<span class="string">&quot;images/T_Reflection_Tiles_D.BMP&quot;</span>, &amp;imgWidth, &amp;imgHeight, <span class="number">0</span>, SOIL_LOAD_RGBA);</span><br></pre></td></tr></table></figure>

<p>读图片.<br><code>SOIL_LOAD_RGBA</code> 当最后一个透明度没有也会强制生成不透明（即值为 1）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, imgWidth, imgHeight, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GL_TEXTURE_2D</code> 区域</li>
<li>第 <code>0</code> 层</li>
<li>目标区域 <code>RGBA</code></li>
<li>宽高</li>
<li>边缘部分处理</li>
<li>和读取时候的最后一个参数一致</li>
<li>数据类型</li>
<li>图片</li>
</ul>
<p>生成后即可解绑定.<br>​</p>
<p>​</p>
<p><code>glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture0&quot;), 0);</code><br>while 中将纹理图片和纹理坐标对应<br>​</p>
<p><code>uniform sampler2D texture0;</code><br><code>sampler2D</code> 实际上是 int 型<br>​</p>
<p><code>glUniform1i(glGetUniformLocation(ourShader.Program, &quot;texture0&quot;), 0);</code><br>这里第二个参数传 0 代表位置即可，不用是变量<br>​</p>
<p><code>ourTextCoord = vec2(textCoord.x, 1 - textCoord.y);</code><br><code>vertexShader</code>中不这么设置，直接传的是上下颠倒的！<br>因为 OpenGL 要求 y 轴 0.0 坐标是在图片的底部的，但是图片的 y 轴 0.0 坐标通常在顶部<br>​</p>
<h2 id="Week-7-1"><a href="#Week-7-1" class="headerlink" title="Week 7-1"></a>Week 7-1</h2><p>简单增加 36 个三角形<br>vertices 中交换两块的位置，看到的颜色会变</p>
<h3 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3><p>新加入的颜色信息会覆盖原有的，你的立方体可能背面显示在正面之前了…</p>
<p><code>glEnable(GL_DEPTH_TEST);</code><br>开启深度测试<br><code>glDepthFunc(GL_LESS);</code><br>当小于再改变<br>​</p>
<p><code>glClear(GL_COLOR_BUFFER_BIT | **GL_DEPTH_BUFFER**);</code><br>while 中添加，使不要每次重新绘制</p>
<p>此时编译出来的正面就不是绿色而是红色了<br>​</p>
<p>只有深度、模板、颜色每次开启时需要重新初始化（while<br>其它不用<br>​</p>
<h3 id="正方体的平移、旋转和缩放"><a href="#正方体的平移、旋转和缩放" class="headerlink" title="正方体的平移、旋转和缩放"></a>正方体的平移、旋转和缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">GLuint transLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br></pre></td></tr></table></figure>

<p>获得位置、数量、不进行转置、uniform 形式传值<br>​</p>
<p><code>GLSL</code> 两种获得输入的方式：</p>
<ul>
<li><code>_in_</code>_ 来自显存_</li>
<li><code>_uniform_</code>_ 来自 CPU_</li>
</ul>
<p>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform = glm::<span class="built_in">rotate</span>(transform, glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>)*<span class="keyword">static_cast</span>&lt;GLfloat&gt;(<span class="built_in">glfwGetTime</span>()), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure>

<p>绕 (1,1,1) 向量轴旋转。<br><code>static_cast&lt;GLfloat&gt;(glfwGetTime())</code><br>临时使用的时间系数。<br>​</p>
<p><code>transform = glm::scale(transform, glm::vec3(0.5f, 0.5f, 0.5f));</code><br>缩放实际上是针对对角线的点操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line">glm::mat4 transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.4f</span>, <span class="number">0.0f</span>));</span><br><span class="line">transform = glm::<span class="built_in">rotate</span>(transform, glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>) * <span class="keyword">static_cast</span>&lt;GLfloat&gt;(<span class="built_in">glfwGetTime</span>()), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">transform = glm::<span class="built_in">scale</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">GLuint transLoc = <span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(transLoc, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br></pre></td></tr></table></figure>

<p>各个变换的顺序有意义，后写的先执行！！！<br>将值通过 <code>uniform</code> 形式传送给着色器，这样你可以在着色器使用 <code>uniform mat4 transform</code> 接收。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectorShader</span></span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	gl_Position = transform * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);</span><br><span class="line">	ourColor = vertexColor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<h2 id="Week-7-2"><a href="#Week-7-2" class="headerlink" title="Week 7-2"></a>Week 7-2</h2><h3 id="在透视矩阵加持下，生成真正的正方体"><a href="#在透视矩阵加持下，生成真正的正方体" class="headerlink" title="在透视矩阵加持下，生成真正的正方体"></a>在透视矩阵加持下，生成真正的正方体</h3><blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/#3d">【LearnOpenGL】坐标系统 | 进入 3D</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), <span class="built_in"><span class="keyword">float</span></span>(screenWidth) / <span class="built_in"><span class="keyword">float</span></span>(screenHeight), <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;projection&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(projection));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectorShader</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 position;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec2 textCoord;</span><br><span class="line"></span><br><span class="line">out vec2 ourTextCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	gl_Position =  projection * transform * <span class="built_in">vec4</span>(position, <span class="number">1.0f</span>);		<span class="comment">// 注意顺序</span></span><br><span class="line">	ourTextCoord = <span class="built_in">vec2</span>(textCoord.x, <span class="number">1</span> - textCoord.y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各个变换的顺序有意义，后写的先执行！！！<br><em>​</em></p>
<h2 id="Week-8-1"><a href="#Week-8-1" class="headerlink" title="Week 8-1"></a>Week 8-1</h2><h3 id="Camera-h-构造函数"><a href="#Camera-h-构造函数" class="headerlink" title="Camera.h 构造函数"></a>Camera.h 构造函数</h3><blockquote>
<p>你可以复习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40162095/article/details/106379853?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-5.no_search_link&spm=1001.2101.3001.4242.4">c++ 带参构造函数与初始化列表</a></p>
</blockquote>
<p>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Camera</span>(glm::vec3 nPosition = DEFAULT_POSITION)</span><br><span class="line">	:</span><br><span class="line">	<span class="built_in">cameraPosition</span>(nPosition),</span><br><span class="line">	<span class="built_in">worldUp</span>(DEFAULT_WORLD_UP),</span><br><span class="line">	<span class="built_in">yaw</span>(DEFAULT_YAW),</span><br><span class="line">	<span class="built_in">pitch</span>(DEFAULT_PITCH),</span><br><span class="line">	<span class="built_in">movementSpeed</span>(DEFAULT_SPEED),</span><br><span class="line">	<span class="built_in">cameraFront</span>(DEFAULT_CAMERA_FRONT),</span><br><span class="line">	<span class="built_in">zoom</span>(DEFAULT_ZOOM)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">updateCameraVectors</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以上使用初始化列表的写法等价于下面这种：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Camera</span>(glm::vec3 nPosition = DEFAULT_POSITION)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;position = nPosition;</span><br><span class="line">		<span class="keyword">this</span>-&gt;worldUp = DEFAULT_WORLD_UP;</span><br><span class="line">		<span class="keyword">this</span>-&gt;yaw = DEFAULT_YAW;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pitch = DEFAULT_PITCH;</span><br><span class="line">		<span class="keyword">this</span>-&gt;movementSpeed = DEFAULT_SPEED;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cameraFront = DEFAULT_CAMERA_FRONT;</span><br><span class="line">		<span class="keyword">this</span>-&gt;zoom = DEFAULT_ZOOM;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">updateCameraVectors</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老师上课时的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Camera</span>(glm::vec3 position = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">		glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">		GLfloat yaw = DEFAULT_YAW,</span><br><span class="line">		GLfloat pitch = DEFAULT_PITCH) :<span class="built_in">cameraFront</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>)), <span class="built_in">zoom</span>(DEFAULT_ZOOM), <span class="built_in">movementSpeed</span>(DEFAULT_SPEED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;position = position;</span><br><span class="line">		<span class="keyword">this</span>-&gt;worldUp = up;</span><br><span class="line">		<span class="keyword">this</span>-&gt;yaw = yaw;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pitch = pitch;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">updateCameraVectors</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>以上这三段代码实现的结果一致。<br>​</p>
<h3 id="摄像机观察空间"><a href="#摄像机观察空间" class="headerlink" title="摄像机观察空间"></a>摄像机观察空间</h3><p>[</p>
<p>](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/</a>)</p>
<blockquote>
<p>你可以参考：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">【LearnOpenGL】摄像机</a></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636793080478-8a032b0e-082e-46fe-8c3d-c190ef80573e.png#clientId=u0547b413-7070-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5f47f61e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=800&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=22350&status=done&style=none&taskId=u4a70bf1a-58b4-4e7e-b4ba-27df50e4da9&title=" alt="image.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摄像机坐标</span></span><br><span class="line">glm::vec3 position;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界坐标系下的一个向上（y）的方向向量，我们会定义它为（0，1，0）</span></span><br><span class="line">glm::vec3 worldUp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// front(`Direction` in the pic), camera axis Z, 相机坐标系的 Z 轴</span></span><br><span class="line">glm::vec3 cameraFront;</span><br><span class="line"></span><br><span class="line"><span class="comment">// right, camera axis X, 相机坐标系的 X 轴</span></span><br><span class="line">glm::vec3 cameraRight;</span><br><span class="line"></span><br><span class="line"><span class="comment">// up, camera axis Y, 相机坐标系的 Y 轴</span></span><br><span class="line">glm::vec3 cameraUp;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateCameraVectors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		glm::vec3 front;</span><br><span class="line">		front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="keyword">this</span>-&gt;pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="keyword">this</span>-&gt;yaw));</span><br><span class="line">		front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(<span class="keyword">this</span>-&gt;pitch));</span><br><span class="line">		front.z = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(<span class="keyword">this</span>-&gt;pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(<span class="keyword">this</span>-&gt;yaw));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">		<span class="keyword">this</span>-&gt;cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(<span class="keyword">this</span>-&gt;cameraFront, <span class="keyword">this</span>-&gt;worldUp));</span><br><span class="line">		<span class="keyword">this</span>-&gt;cameraUp = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(<span class="keyword">this</span>-&gt;cameraRight, <span class="keyword">this</span>-&gt;cameraFront));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​</p>
<p><code>this-&gt;cameraRight = glm::normalize(glm::cross(this-&gt;cameraFront, this-&gt;worldUp));</code><br>和 LearnOpenGL 的教程有点不一样。<br>是因为我们课程里的 camera front 设置为反方向，教程接下来就用了这种方法<br>​</p>
<p><code>this-&gt;worldUp</code> 的引入是因为只有相机坐标系的 z 方向是没办法确定 x 方向的，但是利用叉积的原理，我们并不需要准确的 y 方向，找一个在同一平面的作叉积就得到相同的结果，所以我们自然的选择了世界坐标系下的 y 方向向量。<br>​</p>
<blockquote>
<p><em>使用矩阵的好处之一是如果你使用 3 个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这 3 个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是 <em><strong><em>LookAt</em></strong></em> 矩阵所做的，现在我们有了 3 个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的 LookAt 矩阵了：</em> &gt; <img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636794661074-c9c8dccd-fac2-4b1f-892b-b8712407a5c1.png#clientId=u0547b413-7070-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=163&id=u1589c720&margin=%5Bobject%20Object%5D&name=image.png&originHeight=163&originWidth=546&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10840&status=done&style=none&taskId=u91f56aa1-8349-4ee4-9098-4cff3c1bb0b&title=&width=546" alt="image.png"> &gt; <em>LookAt=[RxRyRz0UxUyUz0DxDyDz00001]∗[100−Px010−Py001−Pz0001]</em> &gt; <em>其中 R 是右向量，U 是上向量，D 是方向向量 P 是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个 LookAt 矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt 矩阵就像它的名字表达的那样：它会创建一个看着 (Look at) 给定目标的观察矩阵。</em></p>
</blockquote>
<blockquote>
<p><em>我们首先将摄像机位置设置为之前定义的 cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新 cameraPos 向量。</em></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::mat4 <span class="title">GetViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> glm::<span class="built_in">lookAt</span>(<span class="keyword">this</span>-&gt;position, <span class="keyword">this</span>-&gt;position + <span class="keyword">this</span>-&gt;cameraFront, <span class="keyword">this</span>-&gt;cameraUp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<h3 id="键盘控制摄像机视角移动"><a href="#键盘控制摄像机视角移动" class="headerlink" title="键盘控制摄像机视角移动"></a>键盘控制摄像机视角移动</h3><p>不同设备帧率不同，可能会导致移动速度不一样。我们利用时间一致，用时间来控制移动速度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoMovement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_W] || keys[GLFW_KEY_UP])</span><br><span class="line">	&#123;</span><br><span class="line">		camera.<span class="built_in">ProcessKeyboard</span>(FORWARD, deltaTime);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_S] || keys[GLFW_KEY_DOWN])</span><br><span class="line">	&#123;</span><br><span class="line">		camera.<span class="built_in">ProcessKeyboard</span>(BACKWARD, deltaTime);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_A] || keys[GLFW_KEY_LEFT])</span><br><span class="line">	&#123;</span><br><span class="line">		camera.<span class="built_in">ProcessKeyboard</span>(LEFT, deltaTime);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (keys[GLFW_KEY_D] || keys[GLFW_KEY_RIGHT])</span><br><span class="line">	&#123;</span><br><span class="line">		camera.<span class="built_in">ProcessKeyboard</span>(RIGHT, deltaTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(GLfloat xOffset, GLfloat yOffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	xOffset *= <span class="keyword">this</span>-&gt;mouseSensitivity;</span><br><span class="line">	yOffset *= <span class="keyword">this</span>-&gt;mouseSensitivity;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;yaw += xOffset;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pitch += yOffset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">updateCameraVectors</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的 xpos 和 ypos 会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个 bool 变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为 xpos 和 ypos 值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</em></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessMouseMovement</span><span class="params">(GLfloat xOffset, GLfloat yOffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	xOffset *= <span class="keyword">this</span>-&gt;mouseSensitivity;</span><br><span class="line">	yOffset *= <span class="keyword">this</span>-&gt;mouseSensitivity;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;yaw += xOffset;</span><br><span class="line">	<span class="keyword">this</span>-&gt;pitch += yOffset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">updateCameraVectors</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>当滚动鼠标滚轮的时候，yoffset 值代表我们竖直滚动的大小。当 scroll_callback 函数被调用后，我们改变全局变量 fov 变量的内容。因为 45.0f 是默认的视野值，我们将会把缩放级别 (Zoom Level) 限制在 1.0f 到 45.0f。</em></p>
</blockquote>
<h2 id="Week-8-2-amp-Week-8-3"><a href="#Week-8-2-amp-Week-8-3" class="headerlink" title="Week 8-2 &amp; Week 8-3"></a>Week 8-2 &amp; Week 8-3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 原立方体 */</span></span><br><span class="line"></span><br><span class="line">ourShader.<span class="built_in">Use</span>();</span><br><span class="line"></span><br><span class="line">glm::mat4 transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// transform = glm::translate(transform, glm::vec3(0.0f, 0.0f, -2.0f));</span></span><br><span class="line">transform = glm::<span class="built_in">rotate</span>(transform, glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"><span class="comment">// transform = glm::scale(transform, glm::vec3(0.5f, 0.5f, 0.5f));</span></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;transform&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br><span class="line"></span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(camera.<span class="built_in">GetZoom</span>()), <span class="built_in"><span class="keyword">float</span></span>(screenWidth) / <span class="built_in"><span class="keyword">float</span></span>(screenHeight), <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;projection&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(projection));</span><br><span class="line"></span><br><span class="line">glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;view&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(view));</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">glUniform3f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;LightPos&quot;</span>), lightPos.x, lightPos.y, lightPos.z);</span><br><span class="line"><span class="built_in">glUniform3f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;ViewPos&quot;</span>), camera.<span class="built_in">GetPosition</span>().x, camera.<span class="built_in">GetPosition</span>().y, camera.<span class="built_in">GetPosition</span>().z);</span><br><span class="line"><span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;material.diffuse&quot;</span>), DIFFUSE);</span><br><span class="line"><span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;material.specular&quot;</span>), SPECULAR);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 光源立方体 */</span></span><br><span class="line"></span><br><span class="line">lightShader.<span class="built_in">Use</span>();</span><br><span class="line"></span><br><span class="line">glm::mat4 transformLight = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">lightPos = glm::<span class="built_in">rotate</span>(lightPos, glm::<span class="built_in">radians</span>(<span class="number">0.05f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">transformLight = glm::<span class="built_in">translate</span>(transformLight, lightPos);</span><br><span class="line">transformLight = glm::<span class="built_in">scale</span>(transformLight, glm::<span class="built_in">vec3</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(lightShader.Program, <span class="string">&quot;transform&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transformLight));</span><br><span class="line"></span><br><span class="line">glm::mat4 projectionLight = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(camera.<span class="built_in">GetZoom</span>()), <span class="built_in"><span class="keyword">float</span></span>(screenWidth) / <span class="built_in"><span class="keyword">float</span></span>(screenHeight), <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(lightShader.Program, <span class="string">&quot;projection&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(projectionLight));</span><br><span class="line"></span><br><span class="line">glm::mat4 viewLight = camera.<span class="built_in">GetViewMatrix</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(lightShader.Program, <span class="string">&quot;view&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(viewLight));</span><br><span class="line"></span><br><span class="line">lightModel.<span class="built_in">Draw</span>();</span><br></pre></td></tr></table></figure>

<p>除去光照部分的设置，两立方体的设置都是对称的格式！<br>​</p>
<h2 id="思考：OpenGL-z-轴方向问题"><a href="#思考：OpenGL-z-轴方向问题" class="headerlink" title="思考：OpenGL z 轴方向问题"></a>思考：OpenGL z 轴方向问题</h2><p>OpenGL 中世界坐标系下，是遵循右手准则的。DX 中才是左手准则。<br>​</p>
<p>当我们转换到相机坐标系下后，OpenGl 会对坐标进行归一化处理（归一化设备坐标系 NDC）。这里有一个问题，NDC 是遵循左手准则的。<br>​</p>
<p>这在相机坐标系下，对归一化后的 NDC 来说，近的物体（z 轴）坐标值要小于远处的物体。<br>而我们最开始定义 vertices 的时候，是按照世界坐标系定义的，如果我们没有处理，直接传给 NDC 坐标系，所以这会导致 z 轴设置的前后对称（相反）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>​</p>
<p>一般的，解决方法是在将世界坐标系下的坐标传入 NDC 之前，我们会对其用投影矩阵转换输入的顶点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in vec3 aPos;</span><br><span class="line">mat4 modelProjectionMatrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = modelProjectionMatrix * <span class="built_in">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_projectionmatrix.html"><strong>OpenGL Projection Matrix</strong></a></p>
<blockquote>
<p><em>Note that both xp and yp depend on ze; they are inversely propotional to -ze. In other words, they are both divided by -ze. It is a very first clue to construct GL_PROJECTION matrix. After the eye coordinates are transformed by multiplying GL_PROJECTION matrix, the clip coordinates are still a <em><a target="_blank" rel="noopener" href="http://www.songho.ca/math/homogeneous/homogeneous.html"><em>homogeneous coordinates</em></a></em>. It finally becomes the normalized device coordinates (NDC) by divided by the w-component of the clip coordinates. (See more details on <em><a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_transform.html"><em>OpenGL Transformation</em></a></em>.)</em> &gt; <em>…</em> &gt; <em>Finally, we found all entries of GL_PROJECTION matrix. The complete projection <em><a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_matrix.html"><em>matrix</em></a></em> is;</em> &gt; <img src="https://cdn.nlark.com/yuque/0/2021/png/1721297/1636720432429-6052b751-8512-4ed2-b286-a90d00e9ad02.png#clientId=u042d757e-e23a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=90&id=LhZEE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=516&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15759&status=done&style=none&taskId=u17d87bf1-7a4f-4ef2-aafa-8e4c4249ed0&title=&width=124.671875" alt="image.png"></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50671462/opengl-z-value-why-negative-value-in-front"><strong>stackoverflow | opengl-z-value-why-negative-value-in-front</strong></a></p>
<blockquote>
<p><em>Of course the red triangle is in front of the blue one, because you don’t use any projection matrix. You forgot to transform the input vertex by the projection matrix before you assign the vertex coordinate to gl_Position.</em> &gt; <em>This causes that the vertices are equal to the normalized device space coordinates. In normalized device space the z-axis points into the viewport and the “projection” is orthographic and not perspective.</em></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/db53d8d3b14e"><strong>简书：OpenGL NDC 左手还是右手</strong></a></p>
<blockquote>
<p>null</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://ask.csdn.net/questions/676264"><strong>CSDN | OpenGL 默认的 Z 轴方向问题</strong></a></p>
<blockquote>
<p><em>OpenGL 的 NDC 默认是左手坐标系（Z 轴正方向指向屏幕内侧），范围为（-1.0， 1.0）；<br>OpenGL 的空间坐标系使用右手坐标系，Z 轴正方向指向屏幕外侧；</em> &gt; <em>上面代码中传入的坐标没有经过变换（MVP），直接赋值作为最终的 NDC 坐标，因此展现了这种情况</em></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/"><strong>GitHub | LearnOpenGL | 坐标系统</strong></a></p>
<blockquote>
<p><em>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型 (Model)、观察 (View)、投影 (Projection) 三个矩阵。我们的顶点坐标起始于局部空间 (Local Space)，在这里它称为局部坐标 (Local Coordinate)，它在之后会变为世界坐标 (World Coordinate)，观察坐标 (View Coordinate)，裁剪坐标 (Clip Coordinate)，并最后以屏幕坐标 (Screen Coordinate) 的形式结束。</em></p>
</blockquote>
<p>​</p>
<h1 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h1><h2 id="第-1-次作业：矩形颜色交替变换"><a href="#第-1-次作业：矩形颜色交替变换" class="headerlink" title="第 1 次作业：矩形颜色交替变换"></a>第 1 次作业：矩形颜色交替变换</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.cpp */</span></span><br><span class="line"><span class="comment">// 逐帧画图</span></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, screenWidth, screenHeight);</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();</span><br><span class="line">		<span class="built_in">glClearColor</span>(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用着色器绘制一个三角形</span></span><br><span class="line">		ourShader.<span class="built_in">Use</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 作业 1 颜色交替</span></span><br><span class="line">		<span class="keyword">float</span> time = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">		<span class="keyword">float</span> colorValue = ( <span class="built_in">sin</span>(time) / <span class="number">2</span> ) + <span class="number">0.5</span>;</span><br><span class="line">		<span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;colorValue&quot;</span>), colorValue);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">		<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">		<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>float time = glfwGetTime();</code><br>很大的值<br>​</p>
<p><code>float colorValue = ( sin(time) / 2 ) + 0.5;</code><br>写法不唯一，只是让 time 值变小，并且为正，使其在 0 到 1 变化（颜色范围边界是 0~1）<br>​</p>
<p><code>glUniform1f(glGetUniformLocation(ourShader.Program, &quot;colorValue&quot;), colorValue);</code><br>传送 1f 即 1 个 float<br>​</p>
<p>查询 uniform 地址不要求你之前使用过着色器程序，但是更新一个 uniform 之前你必须先使用程序（调用 glUseProgram)，因为它是在当前激活的着色器程序中设置 uniform 的。<br>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .fs */</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in vec3 vertexColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> colorValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	color = <span class="built_in">vec4</span>(vertexColor.x,</span><br><span class="line">					vertexColor.y + colorValue,</span><br><span class="line">						vertexColor.z,</span><br><span class="line">				<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uniform float colorValue;</code><br>接收传送内容<br>​</p>
<p><code>color = vec4(vertexColor.x, vertexColor.y + colorValue, vertexColor.z, 1.0f);</code><br>colorValue 从 0~0.5 变化<br>​</p>
<p>此时由于预定义三角形颜色 <code>vertexColor = (1, 0, 0)</code> 红色<br><code>color = (1, 0 + colorValue, 0)</code> 在 <code>(1, 0, 0)</code>红色 和 <code>(1, 1, 0)</code> 橙色 之间变化.</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><p>传 vec4，这样的话原来传的值就被这里新定义的覆盖了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUniform4f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;newVertexColor&quot;</span>), <span class="number">1.0f</span>, colorValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .fs */</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">out vec4 color;</span><br><span class="line"></span><br><span class="line">in vec3 vertexColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 newVertexColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	color = <span class="built_in">vec4</span>(newVertexColor);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第-2-次作业：纹理替换"><a href="#第-2-次作业：纹理替换" class="headerlink" title="第 2 次作业：纹理替换"></a>第 2 次作业：纹理替换</h2><blockquote>
<p>睿的要求：纹理变化常通过纹理平移来实现，所以不只是渐变，还要平移！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 作业 2 纹理交替变换 ---- BEG</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> time = <span class="built_in">glfwGetTime</span>();</span><br><span class="line">		<span class="keyword">float</span> translateValue = <span class="built_in">fmodf</span>(time, <span class="number">10.0f</span>) / <span class="number">10.0f</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (((<span class="keyword">int</span>)time / <span class="number">10</span>) % <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">			<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture0);</span><br><span class="line">			<span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;texture0&quot;</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">			<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">			<span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;texture1&quot;</span>), <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">			<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture0);</span><br><span class="line">			<span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;texture0&quot;</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">glActiveTexture</span>(GL_TEXTURE1);</span><br><span class="line">			<span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture1);</span><br><span class="line">			<span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glUniform1f</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;translateValue&quot;</span>), translateValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 作业 2 纹理交替变换 ---- END</span></span><br></pre></td></tr></table></figure>

<p>if 语句的作用是使纹理始终沿一个方向变化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .vs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec2 textCoord;</span><br><span class="line">out vec2 ourTextCoord;</span><br><span class="line">out <span class="keyword">float</span> ourTranslateValue;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> translateValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	ourTextCoord = <span class="built_in">vec2</span>(textCoord.x, <span class="number">1</span> - textCoord.y - translateValue);</span><br><span class="line">	ourTranslateValue = translateValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .fs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line">in vec2 ourTextCoord;</span><br><span class="line">in <span class="keyword">float</span> ourTranslateValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    color = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture0, ourTextCoord), <span class="built_in">texture</span>(texture1, ourTextCoord), ourTranslateValue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 mix() 实现渐变，最后一个参数是线性插值，[0,1] ，极端值分别取首个、第二个纹理。<br>修改纹理坐标，使纹理移动。<br>顺便利用这个变量 <code>translateValue</code>，进行线性插值，实现纹理的渐变转换。<br>​</p>
<h2 id="第-3-次作业：地月模型"><a href="#第-3-次作业：地月模型" class="headerlink" title="第 3 次作业：地月模型"></a>第 3 次作业：地月模型</h2><blockquote>
<p>根据本次作业布置的时间，本次作业没有利用摄像机视角，没有利用光源模型。</p>
</blockquote>
<p>​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newPos = glm::<span class="built_in">rotate</span>(newPos, glm::<span class="built_in">radians</span>(<span class="number">0.1f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(newPos.x, newPos.y, newPos.z - <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p><code>glm::rotate</code> 的第 3 个参数是根据从坐标原点 <code>(0, 0, 0)</code> 出发的向量的轴旋转的。<br>由于我们设置了中心正方体的坐标在 <code>(0, 0, -2)</code>（因为此时人也在原点），所以我们需要把坐标在原点设置完自转效果，再通过 <code>glm::rotate</code> 移动到 <code>(0, 0, -2)</code>。<br>​</p>
<p>⚠ 注意：必须加上这个附加库的头文件使用：<br><code>#include &lt;glm/gtx/rotate_vector.hpp&gt;</code><br>​</p>
<p>我重复利用同一个正方体的顶点数据 <code>vertices[]</code>，去生成大小位置不一样的两个正方体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ourShader.<span class="built_in">Use</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glm::mat4 transform;</span><br><span class="line">glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), <span class="built_in"><span class="keyword">float</span></span>(screenWidth) / <span class="built_in"><span class="keyword">float</span></span>(screenHeight), <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;projection&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(projection));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中心正方体（地球） */</span></span><br><span class="line"></span><br><span class="line">transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-2.0f</span>));</span><br><span class="line">transform = glm::<span class="built_in">rotate</span>(transform, glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>) * <span class="keyword">static_cast</span>&lt;GLfloat&gt;(<span class="built_in">glfwGetTime</span>()), glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(<span class="number">23.5</span> * PI / <span class="number">180</span>), <span class="built_in">cos</span>(<span class="number">23.5</span> * PI / <span class="number">180</span>), <span class="number">0</span>));</span><br><span class="line">transform = glm::<span class="built_in">scale</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;transform&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 旋转正方体（月球） */</span></span><br><span class="line"></span><br><span class="line">transform = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">newPos = glm::<span class="built_in">rotate</span>(newPos, glm::<span class="built_in">radians</span>(<span class="number">0.05f</span>), glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(<span class="number">23.5</span> * PI / <span class="number">180</span>), <span class="built_in">cos</span>(<span class="number">23.5</span> * PI / <span class="number">180</span>) , <span class="number">0</span>));</span><br><span class="line">transform = glm::<span class="built_in">translate</span>(transform, glm::<span class="built_in">vec3</span>(newPos.x, newPos.y, newPos.z - <span class="number">2</span>));</span><br><span class="line">transform = glm::<span class="built_in">rotate</span>(transform, glm::<span class="built_in">radians</span>(<span class="number">20.0f</span>) * <span class="keyword">static_cast</span>&lt;GLfloat&gt;(<span class="built_in">glfwGetTime</span>()), glm::<span class="built_in">vec3</span>(<span class="built_in">sin</span>(<span class="number">23.5</span> * PI / <span class="number">180</span>), <span class="built_in">cos</span>(<span class="number">23.5</span> * PI / <span class="number">180</span>), <span class="number">0</span>));</span><br><span class="line">transform = glm::<span class="built_in">scale</span>(transform, glm::<span class="built_in">vec3</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.Program, <span class="string">&quot;transform&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(transform));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>​</p>
<h2 id="第-4-次作业：实现控制物体的移动"><a href="#第-4-次作业：实现控制物体的移动" class="headerlink" title="第 4 次作业：实现控制物体的移动"></a>第 4 次作业：实现控制物体的移动</h2><p>引入物体坐标变量 <code>ObjectPos</code>。<br>​</p>
<p><code>DoMovement()</code> 函数针对物体坐标进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物体上下左右（↑/↓/←/→）移动</span></span><br><span class="line"> <span class="keyword">if</span> (keys[GLFW_KEY_UP]) &#123;</span><br><span class="line">	ObjectPos.y += deltaTime * OBJECT_SPEED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (keys[GLFW_KEY_DOWN]) &#123;</span><br><span class="line">	ObjectPos.y -= deltaTime * OBJECT_SPEED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (keys[GLFW_KEY_LEFT]) &#123;</span><br><span class="line">	ObjectPos.x -= deltaTime * OBJECT_SPEED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (keys[GLFW_KEY_RIGHT]) &#123;</span><br><span class="line">	ObjectPos.x += deltaTime * OBJECT_SPEED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次循环时应该更新物体的坐标，因为现在它可能在 <code>DoMovement()</code>中被修改了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform = glm::<span class="built_in">translate</span>(transform, ObjectPos);</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>NJUPT-CG-OpenGL</p><p><a href="http://www.toulzx.top/2021/11/19/njupt-cg-opengl/">http://www.toulzx.top/2021/11/19/njupt-cg-opengl/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>tou</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-11-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-12-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/12/10/guide_to_unix_and_linux/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">GUIDE TO UNIX AND LINUX</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/20/yuque-hexo-guide/"><span class="level-item">yuque-hexo 自动化同步： PC &amp; GitHub &amp; Server 的安装与配置</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/57480529?v=4" alt="tou"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">tou</p><p class="is-size-6 is-block">Student majoring in CS</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-10T00:11:32.000Z">2021-12-10</time></p><p class="title"><a href="/2021/12/10/guide_to_unix_and_linux/">GUIDE TO UNIX AND LINUX</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-11-19T09:58:29.000Z">2021-11-19</time></p><p class="title"><a href="/2021/11/19/njupt-cg-opengl/">NJUPT-CG-OpenGL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-20T05:29:08.000Z">2021-09-20</time></p><p class="title"><a href="/2021/09/20/yuque-hexo-guide/">yuque-hexo 自动化同步： PC &amp; GitHub &amp; Server 的安装与配置</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-19T17:12:55.000Z">2021-09-20</time></p><p class="title"><a href="/2021/09/20/yuque-github-hexo/">语雀 + GitHub + Hexo 三端同步的自动化部署博客的搭建</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-18T01:56:29.000Z">2021-09-18</time></p><p class="title"><a href="/2021/09/18/test/">Hello World</a></p></div></article></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#README"><span class="level-left"><span class="level-item">1</span><span class="level-item">README</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#声明"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">声明</span></span></a></li><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#如何食用"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">如何食用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#项目结构"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">项目结构</span></span></a></li><li><a class="level is-mobile" href="#查阅历次代码及差异"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">查阅历次代码及差异</span></span></a></li></ul></li><li><a class="level is-mobile" href="#历次课程代码"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">历次课程代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文件夹目录链接"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">文件夹目录链接</span></span></a></li><li><a class="level is-mobile" href="#下载"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">下载</span></span></a></li></ul></li><li><a class="level is-mobile" href="#友情链接"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">友情链接</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关于教程"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">关于教程</span></span></a></li><li><a class="level is-mobile" href="#课程笔记-amp-代码"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">课程笔记 &amp; 代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#一点建议"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">一点建议</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Notes"><span class="level-left"><span class="level-item">2</span><span class="level-item">Notes</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Week-2-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Week 2-1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#初始环境配置"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">初始环境配置</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#配置附加库目录，并使用静态链接的方式引用"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">配置附加库目录，并使用静态链接的方式引用</span></span></a></li><li><a class="level is-mobile" href="#在项目属性配置中，将附加库的目录添加进来"><span class="level-left"><span class="level-item">2.1.1.2</span><span class="level-item">在项目属性配置中，将附加库的目录添加进来</span></span></a></li><li><a class="level is-mobile" href="#在测试代码中引用附加库目录"><span class="level-left"><span class="level-item">2.1.1.3</span><span class="level-item">在测试代码中引用附加库目录</span></span></a></li></ul></li><li><a class="level is-mobile" href="#重写-Demo"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">重写 Demo</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-2-2-amp-Week-3-1"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Week 2-2 &amp; Week 3-1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#顶点着色器（Vector-Shader）"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">顶点着色器（Vector Shader）</span></span></a></li><li><a class="level is-mobile" href="#片元着色器（Fragment-Shader）"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">片元着色器（Fragment Shader）</span></span></a></li><li><a class="level is-mobile" href="#导入并编译着色器"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">导入并编译着色器</span></span></a></li><li><a class="level is-mobile" href="#创建并链接可执行文件"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">创建并链接可执行文件</span></span></a></li><li><a class="level is-mobile" href="#屏幕坐标系"><span class="level-left"><span class="level-item">2.2.5</span><span class="level-item">屏幕坐标系</span></span></a></li><li><a class="level is-mobile" href="#传入数据到显卡"><span class="level-left"><span class="level-item">2.2.6</span><span class="level-item">传入数据到显卡</span></span></a></li><li><a class="level is-mobile" href="#调用着色器"><span class="level-left"><span class="level-item">2.2.7</span><span class="level-item">调用着色器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-3-2"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Week 3-2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关于-Visual-Studio-的“解决方案资源管理器”"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">关于 Visual Studio 的“解决方案资源管理器”</span></span></a></li><li><a class="level is-mobile" href="#关于着色器的文件后缀"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">关于着色器的文件后缀</span></span></a></li><li><a class="level is-mobile" href="#防止头文件重复引用"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">防止头文件重复引用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-4-1"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Week 4-1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用两个三角形拼成正方形"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">使用两个三角形拼成正方形</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-5-1"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Week 5-1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#改用点和连接信息构建正方形"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">改用点和连接信息构建正方形</span></span></a></li><li><a class="level is-mobile" href="#配置-SOIL2"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">配置 SOIL2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-5-2"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Week 5-2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#纹理"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">纹理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-7-1"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">Week 7-1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#深度测试"><span class="level-left"><span class="level-item">2.7.1</span><span class="level-item">深度测试</span></span></a></li><li><a class="level is-mobile" href="#正方体的平移、旋转和缩放"><span class="level-left"><span class="level-item">2.7.2</span><span class="level-item">正方体的平移、旋转和缩放</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-7-2"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">Week 7-2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#在透视矩阵加持下，生成真正的正方体"><span class="level-left"><span class="level-item">2.8.1</span><span class="level-item">在透视矩阵加持下，生成真正的正方体</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-8-1"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">Week 8-1</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Camera-h-构造函数"><span class="level-left"><span class="level-item">2.9.1</span><span class="level-item">Camera.h 构造函数</span></span></a></li><li><a class="level is-mobile" href="#摄像机观察空间"><span class="level-left"><span class="level-item">2.9.2</span><span class="level-item">摄像机观察空间</span></span></a></li><li><a class="level is-mobile" href="#键盘控制摄像机视角移动"><span class="level-left"><span class="level-item">2.9.3</span><span class="level-item">键盘控制摄像机视角移动</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Week-8-2-amp-Week-8-3"><span class="level-left"><span class="level-item">2.10</span><span class="level-item">Week 8-2 &amp; Week 8-3</span></span></a></li><li><a class="level is-mobile" href="#思考：OpenGL-z-轴方向问题"><span class="level-left"><span class="level-item">2.11</span><span class="level-item">思考：OpenGL z 轴方向问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#参考："><span class="level-left"><span class="level-item">2.11.1</span><span class="level-item">参考：</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Exercise"><span class="level-left"><span class="level-item">3</span><span class="level-item">Exercise</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#第-1-次作业：矩形颜色交替变换"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">第 1 次作业：矩形颜色交替变换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#方法-1"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">方法 1</span></span></a></li><li><a class="level is-mobile" href="#方法-2"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">方法 2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第-2-次作业：纹理替换"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">第 2 次作业：纹理替换</span></span></a></li><li><a class="level is-mobile" href="#第-3-次作业：地月模型"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">第 3 次作业：地月模型</span></span></a></li><li><a class="level is-mobile" href="#第-4-次作业：实现控制物体的移动"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">第 4 次作业：实现控制物体的移动</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">tou&#039;s Website</a><p class="is-size-7"><span>Starting from the Mid-Autumn Festival of 2021</span><br>Powered by <span target="_blank" rel="noopener">Hexo</span> &amp; <span target="_blank" rel="noopener">Icarus</span><br><a href="https://beian.miit.gov.cn/" target="_blank">粤 ICP 备 2020135754 号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="repo on GitHub" href="https://github.com/toulzx/toulzx.github.io"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script src="/js/custom.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>